<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDBC加强</title>
      <link href="/2019/01/08/jdbc-lian-jie-chi-jdbctemplate-ke-tang-bi-ji/"/>
      <url>/2019/01/08/jdbc-lian-jie-chi-jdbctemplate-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><p><img src="\images\数据库连接池.bmp" alt=""></p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils {            //1.定义成员变量 DataSource            private static DataSource ds ;            static{                try {                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                } catch (IOException e) {                    e.printStackTrace();                } catch (Exception e) {                    e.printStackTrace();                }            }            /**             * 获取连接             */            public static Connection getConnection() throws SQLException {                return ds.getConnection();            }            /**             * 释放资源             */            public static void close(Statement stmt,Connection conn){               /* if(stmt != null){                    try {                        stmt.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }*/               close(null,stmt,conn);            }</code></pre><p>​<br>                public static void close(ResultSet rs , Statement stmt, Connection conn){</p><p>​<br>                    if(rs != null){<br>                        try {<br>                            rs.close();<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }</p><p>​<br>                    if(stmt != null){<br>                        try {<br>                            stmt.close();<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }</p><pre><code>                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }            }            /**             * 获取连接池方法             */            public static DataSource getDataSource(){                return  ds;            }        }</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：            import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;            import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;            public class JdbcTemplateDemo2 {                //Junit单元测试，可以让方法独立执行</code></pre><p>​<br>                    //1. 获取JDBCTemplate对象<br>                    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());<br>                    /**</p><pre><code>                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1(){                    //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                }                /**                 * 2. 添加一条记录                 */                @Test                public void test2(){                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                }                /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3(){                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                }                /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4(){                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}                }                /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                    for (Map&lt;String, Object&gt; stringObjectMap : list) {                        System.out.println(stringObjectMap);                    }                }                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() {                        @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException {                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                            emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                            return emp;                        }                    });</code></pre><p>​<br>                        for (Emp emp : list) {<br>                            System.out.println(emp);<br>                        }<br>                    }</p><pre><code>                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6_2(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) {                        System.out.println(emp);                    }                }                /**                 * 7. 查询总记录数                 */                @Test                public void test7(){                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                }            }</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库连接池 </tag>
            
            <tag> JDBC Template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC入门</title>
      <link href="/2019/01/07/jdbc-ke-tang-bi-ji/"/>
      <url>/2019/01/07/jdbc-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. JDBC基本概念2. 快速入门3. 对JDBC中各个接口和类详解</code></pre><p><img src="\images\JDBC本质.bmp" alt=""></p><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static {                        try {                            java.sql.DriverManager.registerDriver(new Driver());                        } catch (SQLException E) {                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                        }                    }                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try {                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0){                        System.out.println(&quot;添加成功！&quot;);                    }else{                        System.out.println(&quot;添加失败！&quot;);                    }                } catch (ClassNotFoundException e) {                    e.printStackTrace();                } catch (SQLException e) {                    e.printStackTrace();                }finally {                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null){                        try {                            stmt.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                    if(conn != null){                        try {                            conn.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                }    4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next()){                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                }        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll(){}                3. 实现方法 select * from emp;    5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a            2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils {    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static{        //读取资源文件，获取值。        try {            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }</code></pre><p>​<br>        /**</p><pre><code>     * 获取连接     * @return 连接对象     */    public static Connection getConnection() throws SQLException {        return DriverManager.getConnection(url, user, password);    }    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(Statement stmt,Connection conn){        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }</code></pre><p>​<br>        /**</p><pre><code>     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn){        if( rs != null){            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)            );            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);        2. 代码实现：            public class JDBCDemo9 {                public static void main(String[] args) {                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag){                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    }else{                        System.out.println(&quot;用户名或密码错误！&quot;);                    }</code></pre><p>​<br>                    }</p><p>​<br>​<br>                    /**</p><pre><code>                 * 登录方法                 */                public boolean login(String username ,String password){                    if(username == null || password == null){                        return false;                    }                    //连接数据库判断是否登录成功                    Connection conn = null;                    Statement stmt =  null;                    ResultSet rs = null;                    //1.获取连接                    try {                        conn =  JDBCUtils.getConnection();                        //2.定义sql                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;                        //3.获取执行sql的对象                        stmt = conn.createStatement();                        //4.执行查询                        rs = stmt.executeQuery(sql);                        //5.判断                       /* if(rs.next()){//如果有下一行，则返回true                            return true;                        }else{                            return false;                        }*/                       return rs.next();//如果有下一行，则返回true                    } catch (SQLException e) {                        e.printStackTrace();                    }finally {                        JDBCUtils.close(rs,stmt,conn);                    }</code></pre><p>​<br>                        return false;<br>                    }<br>                }</p><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()         * 当所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务4. 代码：    public class JDBCDemo10 {        public static void main(String[] args) {            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;            try {                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                pstmt2.executeUpdate();                //提交事务                conn.commit();            } catch (Exception e) {                //事务回滚                try {                    if(conn != null) {                        conn.rollback();                    }                } catch (SQLException e1) {                    e1.printStackTrace();                }                e.printStackTrace();            }finally {                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            }</code></pre><p>​<br>            }</p><pre><code>    }</code></pre><p>​            </p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery入门</title>
      <link href="/2019/01/06/jquery-ji-chu-bi-ji/"/>
      <url>/2019/01/06/jquery-ji-chu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>1. JQuery 基础：    1. 概念    2. 快速入门    3. JQuery对象和JS对象区别与转换    4. 选择器    5. DOM操作    6. 案例</code></pre><h1 id="JQuery-基础："><a href="#JQuery-基础：" class="headerlink" title="JQuery 基础："></a>JQuery 基础：</h1><pre><code>1. 概念： 一个JavaScript框架。简化JS开发    * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。    * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已2. 快速入门    1. 步骤：        1. 下载JQuery            * 目前jQuery有三个大版本：                1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，                     功能不再新增。因此一般项目来说，使用1.x版本就可以了，                     最终版本：1.12.4 (2016年5月20日)                2.x：不兼容ie678，很少有人使用，官方只做BUG维护，                     功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，                     最终版本：2.2.4 (2016年5月20日)                3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，                     一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。                     目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）            * jquery-xxx.js 与 jquery-xxx.min.js区别：                1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些                2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快        2. 导入JQuery的js文件：导入min.js文件        3. 使用            var div1 = $(&quot;#div1&quot;);               alert(div1.html());3. JQuery对象和JS对象区别与转换    1. JQuery对象在操作时，更加方便。    2. JQuery对象和js对象方法不通用的.    3. 两者相互转换        * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引)        * js -- &gt; jq : $(js对象)4. 选择器：筛选具有相似特征的元素(标签)    1. 基本操作学习：        1. 事件绑定            //1.获取b1按钮            $(&quot;#b1&quot;).click(function(){                alert(&quot;abc&quot;);            });        2. 入口函数             $(function () {                });             window.onload  和 $(function) 区别                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉                 * $(function)可以定义多次的。        3. 样式控制：css方法             // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);              $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);    2. 分类        1. 基本选择器            1. 标签选择器（元素选择器）                * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素            2. id选择器                 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素            3. 类选择器                * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素            4. 并集选择器：                * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素        2. 层级选择器            1. 后代选择器                * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素                    2. 子选择器                * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素        3. 属性选择器            1. 属性名称选择器                 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器            2. 属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器            3. 复合属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器        4. 过滤选择器            1. 首元素选择器                 * 语法： :first 获得选择的元素中的第一个元素            2. 尾元素选择器                 * 语法： :last 获得选择的元素中的最后一个元素            3. 非元素选择器                * 语法： :not(selector) 不包括指定内容的元素            4. 偶数选择器                * 语法： :even 偶数，从 0 开始计数            5. 奇数选择器                * 语法： :odd 奇数，从 0 开始计数            6. 等于索引选择器                * 语法： :eq(index) 指定索引元素            7. 大于索引选择器                 * 语法： :gt(index) 大于指定索引元素            8. 小于索引选择器                 * 语法： :lt(index) 小于指定索引元素            9. 标题选择器                * 语法： :header 获得标题（h1~h6）元素，固定写法        5. 表单过滤选择器            1. 可用元素选择器                 * 语法： :enabled 获得可用元素            2. 不可用元素选择器                 * 语法： :disabled 获得不可用元素            3. 选中选择器                 * 语法： :checked 获得单选/复选框选中的元素            4. 选中选择器                 * 语法： :selected 获得下拉框选中的元素5. DOM操作    1. 内容操作        1. html(): 获取/设置元素的标签体内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;        2. text(): 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容        3. val()： 获取/设置元素的value属性值    2. 属性操作        1. 通用属性操作            1. attr(): 获取/设置元素的属性            2. removeAttr():删除属性            3. prop():获取/设置元素的属性            4. removeProp():删除属性            * attr和prop区别？                1. 如果操作的是元素的固有属性，则建议使用prop                2. 如果操作的是元素自定义的属性，则建议使用attr        2. 对class属性操作            1. addClass():添加class属性值            2. removeClass():删除class属性值            3. toggleClass():切换class属性                * toggleClass(&quot;one&quot;):                     * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。  如果元素对象上不存在class=&quot;one&quot;，则添加            4. css():    3. CRUD操作:        1. append():父元素将子元素追加到末尾            * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾        2. prepend():父元素将子元素追加到开头            * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头        3. appendTo():            * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾        4. prependTo()：            * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头        5. after():添加元素到元素后边            * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系        6. before():添加元素到元素前边            * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        7. insertAfter()            * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系        8. insertBefore()            * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        9. remove():移除元素            * 对象.remove():将对象删除掉        10. empty():清空元素的所有后代元素。            * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点6. 案例</code></pre><p>​            </p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery高级</title>
      <link href="/2019/01/06/jquery-gao-ji-bi-ji/"/>
      <url>/2019/01/06/jquery-gao-ji-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><pre><code>1. JQuery 高级    1. 动画    2. 遍历    3. 事件绑定    4. 案例    5. 插件</code></pre><h2 id="JQuery-高级"><a href="#JQuery-高级" class="headerlink" title="JQuery 高级"></a>JQuery 高级</h2><pre><code>1. 动画    1. 三种方式显示和隐藏元素        1. 默认显示和隐藏方式            1. show([speed,[easing],[fn]])                1. 参数：                    1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)                    2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;                        * swing：动画执行时效果是 先慢，中间快，最后又慢                        * linear：动画执行时速度是匀速的                    3. fn：在动画完成时执行的函数，每个元素执行一次。            2. hide([speed,[easing],[fn]])            3. toggle([speed],[easing],[fn])        2. 滑动显示和隐藏方式            1. slideDown([speed],[easing],[fn])            2. slideUp([speed,[easing],[fn]])            3. slideToggle([speed],[easing],[fn])        3. 淡入淡出显示和隐藏方式            1. fadeIn([speed],[easing],[fn])            2. fadeOut([speed],[easing],[fn])            3. fadeToggle([speed,[easing],[fn]])2. 遍历    1. js的遍历方式        * for(初始化值;循环结束条件;步长)    2. jq的遍历方式        1. jq对象.each(callback)            1. 语法：                jquery对象.each(function(index,element){});                    * index:就是元素在集合中的索引                    * element：就是集合中的每一个元素对象                    * this：集合中的每一个元素对象            2. 回调函数返回值：                * true:如果当前function返回为false，则结束循环(break)。                * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)        2. $.each(object, [callback])        3. for..of: jquery 3.0 版本之后提供的方式            for(元素对象 of 容器对象)3. 事件绑定    1. jquery标准的绑定方式        * jq对象.事件方法(回调函数)；        * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。            * 表单对象.submit();//让表单提交    2. on绑定事件/off解除绑定        * jq对象.on(&quot;事件名称&quot;,回调函数)        * jq对象.off(&quot;事件名称&quot;)            * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑    3. 事件切换：toggle        * jq对象.toggle(fn1,fn2...)            * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....        * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。             &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;4. 案例    1. 广告显示和隐藏        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt;            &lt;style&gt;                #content{width:100%;height:500px;background:#999}            &lt;/style&gt;            &lt;!--引入jquery--&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script&gt;                /*                    需求：                        1. 当页面加载完，3秒后。自动显示广告                        2. 广告显示5秒后，自动消失。                    分析：                        1. 使用定时器来完成。setTimeout (执行一次定时器)                        2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display                        3. 使用  show/hide方法来完成广告的显示                 */                //入口函数，在页面加载完成之后，定义定时器，调用这两个方法                $(function () {                   //定义定时器，调用adShow方法 3秒后执行一次                   setTimeout(adShow,3000);                   //定义定时器，调用adHide方法，8秒后执行一次                    setTimeout(adHide,8000);                });                //显示广告                function adShow() {                    //获取广告div，调用显示方法                    $(&quot;#ad&quot;).show(&quot;slow&quot;);                }                //隐藏广告                function adHide() {                    //获取广告div，调用隐藏方法                    $(&quot;#ad&quot;).hide(&quot;slow&quot;);                }</code></pre><p>​<br>​<br>                <br>            <br>            <body><br>            <!-- 整体的DIV --><br>            <div><br>                <!-- 广告DIV --><br>                <div id="ad" style="display: none;"><br>                    <img style="width:100%" src="../img/adv.jpg"><br>                </div></div></body></p><pre><code>            &lt;!-- 下方正文部分 --&gt;            &lt;div id=&quot;content&quot;&gt;                正文部分            &lt;/div&gt;        &lt;/div&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 抽奖        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;jquery案例之抽奖&lt;/title&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script language=&#39;javascript&#39; type=&#39;text/javascript&#39;&gt;                /*                    分析：                        1. 给开始按钮绑定单击事件                            1.1 定义循环定时器                            1.2 切换小相框的src属性                                * 定义数组，存放图片资源路径                                * 生成随机数。数组索引</code></pre><p>​            </p><pre><code>                        2. 给结束按钮绑定单击事件                            1.1 停止定时器                            1.2 给大相框设置src属性                 */                var imgs = [&quot;../img/man00.jpg&quot;,                            &quot;../img/man01.jpg&quot;,                            &quot;../img/man02.jpg&quot;,                            &quot;../img/man03.jpg&quot;,                            &quot;../img/man04.jpg&quot;,                            &quot;../img/man05.jpg&quot;,                            &quot;../img/man06.jpg&quot;,                            ];                var startId;//开始定时器的id                var index;//随机角标                $(function () {                    //处理按钮是否可以使用的效果                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</code></pre><p>​<br>                       //1. 给开始按钮绑定单击事件<br>                        $(“#startID”).click(function () {<br>                            // 1.1 定义循环定时器 20毫秒执行一次<br>                            startId = setInterval(function () {<br>                                //处理按钮是否可以使用的效果<br>                                $(“#startID”).prop(“disabled”,true);<br>                                $(“#stopID”).prop(“disabled”,false);</p><p>​<br>                                //1.2生成随机角标 0-6<br>                                index = Math.floor(Math.random() <em> 7);//0.000–0.999 –&gt; </em> 7 –&gt; 0.0—–6.9999<br>                                //1.3设置小相框的src属性<br>                                $(“#img1ID”).prop(“src”,imgs[index]);</p><pre><code>                        },20);                    });</code></pre><p>​<br>                        //2. 给结束按钮绑定单击事件<br>                        $(“#stopID”).click(function () {<br>                            //处理按钮是否可以使用的效果<br>                            $(“#startID”).prop(“disabled”,false);<br>                            $(“#stopID”).prop(“disabled”,true);</p><p>​<br>                           // 1.1 停止定时器<br>                            clearInterval(startId);<br>                           // 1.2 给大相框设置src属性<br>                            $(“#img2ID”).prop(“src”,imgs[index]).hide();<br>                            //显示1秒之后<br>                            $(“#img2ID”).show(1000);<br>                        });<br>                    });</p><p>​<br>​<br>​<br>                </p><pre><code>        &lt;/head&gt;        &lt;body&gt;        &lt;!-- 小像框 --&gt;        &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;            &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;        &lt;/div&gt;        &lt;!-- 大像框 --&gt;        &lt;div                style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;            &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;        &lt;/div&gt;        &lt;!-- 开始按钮 --&gt;        &lt;input                id=&quot;startID&quot;                type=&quot;button&quot;                value=&quot;点击开始&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;        &lt;!-- 停止按钮 --&gt;        &lt;input                id=&quot;stopID&quot;                type=&quot;button&quot;                value=&quot;点击停止&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;</code></pre><p>​<br>            <br>            </p><pre><code>5. 插件：增强JQuery的功能    1. 实现方式：        1. $.fn.extend(object)             * 增强通过Jquery获取的对象的功能  $(&quot;#id&quot;)        2. $.extend(object)            * 增强JQeury对象自身的功能  $/jQuery</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/2019/01/05/javascript-ji-chu-bi-ji/"/>
      <url>/2019/01/05/javascript-ji-chu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. JavaScript基础</code></pre><h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><pre><code>* 概念：    一门客户端脚本语言    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了* 功能：    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。* JavaScript发展史：    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--    ，后来更名为：ScriptEase    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript    3. 1996年，微软抄袭JavaScript开发出JScript语言    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)* ECMAScript：客户端脚本语言的标准    1. 基本语法：        1. 与html结合方式            1. 内部JS：                * 定义&lt;script&gt;，标签体内容就是js代码            2. 外部JS：                * 定义&lt;script&gt;，通过src属性引入外部的js文件            * 注意：                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。                2. &lt;script&gt;可以定义多个。        2. 注释            1. 单行注释：//注释内容            2. 多行注释：/*注释内容*/        3. 数据类型：            1. 原始数据类型(基本数据类型)：                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &#39;abc&#39;                3. boolean: true和false                4. null：一个对象为空的占位符                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined            2. 引用数据类型：对象        4. 变量            * 变量：一小块存储数据的内存空间            * Java语言是强类型语言，而JavaScript是弱类型语言。                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。            * 语法：                * var 变量名 = 初始化值;            * typeof运算符：获取变量的类型。                * 注：null运算后得到的是object        5. 运算符            1. 一元运算符：只有一个运算数的运算符                ++，-- ， +(正号)                  * ++ --: 自增(自减)                    * ++(--) 在前，先自增(自减)，再运算                    * ++(--) 在后，先运算，再自增(自减)                * +(-)：正负号                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换                    * 其他类型转number：                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）                        * boolean转number：true转为1，false转为0            2. 算数运算符                + - * / % ...            3. 赋值运算符                = += -+....            4. 比较运算符                &gt; &lt; &gt;= &lt;= == ===(全等于)                * 比较方式                  1. 类型相同：直接比较                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。                  2. 类型不同：先进行类型转换，再比较                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false            5. 逻辑运算符                &amp;&amp; || !                * 其他类型转boolean：                   1. number：0或NaN为假，其他为真                   2. string：除了空字符串(&quot;&quot;)，其他都是true                   3. null&amp;undefined:都是false                   4. 对象：所有对象都为true            6. 三元运算符                ? : 表达式                var a = 3;                var b = 4;                var c = a &gt; b ? 1:0;                * 语法：                    * 表达式? 值1:值2;                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；        6. 流程控制语句：            1. if...else...            2. switch:                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)                    * switch(变量):                        case 值:                * 在JS中,switch语句可以接受任意的原始数据类型            3. while            4. do...while            5. for        7. JS特殊语法：            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)            2. 变量的定义使用var关键字，也可以不使用                * 用： 定义的变量是局部变量                * 不用：定义的变量是全局变量(不建议)        8. 练习：99乘法表        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;99乘法表&lt;/title&gt;            &lt;style&gt;                td{                    border: 1px solid;                }            &lt;/style&gt;            &lt;script&gt;                document.write(&quot;&lt;table  align=&#39;center&#39;&gt;&quot;);</code></pre><p>​<br>                    //1.完成基本的for循环嵌套，展示乘法表<br>                    for (var i = 1; i &lt;= 9 ; i++) {<br>                        document.write(“<tr>“);<br>                        for (var j = 1; j &lt;=i ; j++) {<br>                            document.write(“<td>“);</td></tr></p><pre><code>                        //输出  1 * 1 = 1                        document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);                        document.write(&quot;&lt;/td&gt;&quot;);                    }                    /*//输出换行                    document.write(&quot;&lt;br&gt;&quot;);*/                    document.write(&quot;&lt;/tr&gt;&quot;);                }                //2.完成表格嵌套                document.write(&quot;&lt;/table&gt;&quot;);            &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 基本对象：        1. Function：函数(方法)对象            1. 创建：                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧                2.                     function 方法名称(形式参数列表){                        方法体                    }                3.                    var 方法名 = function(形式参数列表){                        方法体                   }            2. 方法：            3. 属性：                length:代表形参的个数            4. 特点：                1. 方法定义是，形参的类型不用写,返回值类型也不写。                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数            5. 调用：                方法名称(实际参数列表);        2. Array:数组对象            1. 创建：                1. var arr = new Array(元素列表);                2. var arr = new Array(默认长度);                3. var arr = [元素列表];            2. 方法                join(参数):将数组中的元素按照指定的分隔符拼接为字符串                push()    向数组的末尾添加一个或更多元素，并返回新的长度。            3. 属性                length:数组的长度            4. 特点：                1. JS中，数组元素的类型可变的。                2. JS中，数组长度可变的。        3. Boolean        4. Date：日期对象            1. 创建：                var date = new Date();            2. 方法：                toLocaleString()：返回当前date对象对应的时间本地字符串格式                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差        5. Math：数学对象            1. 创建：                * 特点：Math对象不用创建，直接使用。  Math.方法名();            2. 方法：                random():返回 0 ~ 1 之间的随机数。 含0不含1                ceil(x)：对数进行上舍入。                floor(x)：对数进行下舍入。                round(x)：把数四舍五入为最接近的整数。            3. 属性：                PI        6. Number        7. String        8. RegExp：正则表达式对象            1. 正则表达式：定义字符串的组成规则。                1. 单个字符:[]                    如： [a] [ab] [a-zA-Z0-9_]                    * 特殊符号代表特殊含义的单个字符:                        \d:单个数字字符 [0-9]                        \w:单个单词字符[a-zA-Z0-9_]                2. 量词符号：                    ?：表示出现0次或1次                    *：表示出现0次或多次                    +：出现1次或多次                    {m,n}:表示 m&lt;= 数量 &lt;= n                        * m如果缺省： {,n}:最多n次                        * n如果缺省：{m,} 最少m次                3. 开始结束符号                    * ^:开始                    * $:结束            2. 正则对象：                1. 创建                    1. var reg = new RegExp(&quot;正则表达式&quot;);                    2. var reg = /正则表达式/;                2. 方法                        1. test(参数):验证指定的字符串是否符合正则定义的规范            9. Global            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();            2. 方法：                encodeURI():url编码                decodeURI():url解码                encodeURIComponent():url编码,编码的字符更多                decodeURIComponent():url解码                parseInt():将字符串转为数字                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number                isNaN():判断一个值是否是NaN                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。            3. URL编码               你好世界 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2* BOM* DOM</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级</title>
      <link href="/2019/01/05/javascript-gao-ji-bi-ji/"/>
      <url>/2019/01/05/javascript-gao-ji-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. JavaScript：    1. ECMAScript：    2. BOM：    3. DOM：        1. 事件</code></pre><h2 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h2><pre><code>* 功能：控制html文档的内容* 获取页面标签(元素)对象：Element    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象* 操作Element对象：    1. 修改属性值：        1. 明确获取的对象是哪一个？        2. 查看API文档，找其中有哪些属性可以设置    2. 修改标签体内容：        * 属性：innerHTML        1. 获取元素对象        2. 使用innerHTML属性修改标签体内容</code></pre><h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2><pre><code>* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。    * 造句：  xxx被xxx,我就xxx        * 我方水晶被摧毁后，我就责备对友。        * 敌方水晶被摧毁后，我就夸奖自己。* 如何绑定事件    1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码        1. 事件：onclick--- 单击事件    2. 通过js获取元素对象，指定事件属性，设置一个函数    * 代码：        &lt;body&gt;            &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;  onclick=&quot;fun();&quot;&gt;            &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt;            &lt;script&gt;                function fun(){                    alert(&#39;我被点了&#39;);                    alert(&#39;我又被点了&#39;);                }                function fun2(){                    alert(&#39;咋老点我？&#39;);                }                //1.获取light2对象                var light2 = document.getElementById(&quot;light2&quot;);                //2.绑定事件                light2.onclick = fun2;            &lt;/script&gt;        &lt;/body&gt;</code></pre><p>​        </p><pre><code>* 案例1：电灯开关    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;电灯开关&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt;    &lt;script&gt;        /*            分析：                1.获取图片对象                2.绑定单击事件                3.每次点击切换图片                    * 规则：                        * 如果灯是开的 on,切换图片为 off                        * 如果灯是关的 off,切换图片为 on                    * 使用标记flag来完成         */        //1.获取图片对象        var light = document.getElementById(&quot;light&quot;);        var flag = false;//代表灯是灭的。 off图片        //2.绑定单击事件        light.onclick = function(){            if(flag){//判断如果灯是开的，则灭掉                light.src = &quot;img/off.gif&quot;;                flag = false;            }else{                //如果灯是灭的，则打开                light.src = &quot;img/on.gif&quot;;                flag = true;            }        }    &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><p><img src="..\images\bom对象介绍.png" alt=""></p><p><img src="\images\bom对象介绍.png" alt="">    </p><ol><li><p>概念：Browser Object Model 浏览器对象模型</p><pre><code>     * 将浏览器的各个组成部分封装成对象。</code></pre></li></ol><pre><code>2. 组成：    * Window：窗口对象    * Navigator：浏览器对象    * Screen：显示器屏幕对象    * History：历史记录对象    * Location：地址栏对象3. Window：窗口对象    1. 创建（详见4.特点）    2. 方法         1. 与弹出框有关的方法：            alert()    显示带有一段消息和一个确认按钮的警告框。            confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。                * 如果用户点击确定按钮，则方法返回true                * 如果用户点击取消按钮，则方法返回false            prompt()    显示可提示用户输入的对话框。                * 返回值：获取用户输入的值         2. 与打开关闭有关的方法：            close()    关闭浏览器窗口。                * 谁调用我 ，我关谁            open()    打开一个新的浏览器窗口                * 返回新的Window对象         3. 与定时器有关的方式            setTimeout()    在指定的毫秒数后调用函数或计算表达式。                * 参数：                    1. js代码或者方法对象                    2. 毫秒值                * 返回值：唯一标识，用于取消定时器            clearTimeout()    取消由 setTimeout() 方法设置的 timeout。            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。            clearInterval()    取消由 setInterval() 设置的 timeout。    3. 属性：        1. 获取其他BOM对象：            history            location            Navigator            Screen:            例: var h1 = window.history;                var h2 =history;(window可省略)        2. 获取DOM对象            document（同上）    4. 特点        * Window对象不需要创建可以直接使用 window使用。 window.方法名();        * window引用可以省略。  方法名();            例：alert();4. Location：地址栏对象    1. 创建(获取)：        1. window.location        2. location    2. 方法：        * reload()    重新加载当前文档。刷新    3. 属性        * href    设置或返回完整的 URL。5. History：历史记录对象    1. 创建(获取)：        1. window.history        2. history    2. 方法：        * back()    加载 history 列表中的前一个 URL。        * forward()    加载 history 列表中的下一个 URL。        * go(参数)    加载 history 列表中的某个具体页面。            * 参数：                * 正数：前进几个历史记录                * 负数：后退几个历史记录    3. 属性：        * length    返回当前窗口历史列表中的 URL 数量。</code></pre><h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><p><img src="..\images\DOM树.bmp" alt=""></p><p><img src="\images\DOM树.bmp" alt=""></p><pre><code>* 概念： Document Object Model 文档对象模型    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作* W3C DOM 标准被分为 3 个不同的部分：    * 核心 DOM - 针对任何结构化文档的标准模型        * Document：文档对象        * Element：元素对象        * Attribute：属性对象        * Text：文本对象        * Comment:注释对象        * Node：节点对象，其他5个的父对象    * XML DOM - 针对 XML 文档的标准模型    * HTML DOM - 针对 HTML 文档的标准模型* 核心DOM模型：    * Document：文档对象        1. 创建(获取)：在html dom模型中可以使用window对象来获取            1. window.document            2. document        2. 方法：            1. 获取Element对象：                1. getElementById()    ： 根据id属性值获取元素对象。id属性值一般唯一                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组            2. 创建其他DOM对象：                createAttribute(name)                createComment()                createElement()                createTextNode()        3. 属性    * Element：元素对象        1. 获取/创建：通过document来获取和创建        2. 方法：            1. removeAttribute()：删除属性            2. setAttribute()：设置属性    * Node：节点对象，其他5个的父对象        * 特点：所有dom对象都可以被认为是一个节点        * 方法：            * CRUD dom树：                * appendChild()：向节点的子节点列表的结尾添加新的子节点。                * removeChild()    ：删除（并返回）当前节点的指定子节点。                * replaceChild()：用新节点替换一个子节点。        * 属性：            * parentNode 返回节点的父节点。* HTML DOM    1. 标签体的设置和获取：innerHTML    2. 使用html元素对象的属性    3. 控制元素样式        1. 使用元素的style属性来设置            如：                 //修改样式方式1                div1.style.border = &quot;1px solid red&quot;;                div1.style.width = &quot;200px&quot;;                //font-size--&gt; fontSize                div1.style.fontSize = &quot;20px&quot;;        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</code></pre><h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><pre><code>* 概念：某些组件被执行了某些操作后，触发某些代码的执行。        * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了    * 事件源：组件。如： 按钮 文本输入框...    * 监听器：代码。    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。* 常见的事件：    1. 点击事件：        1. onclick：单击事件        2. ondblclick：双击事件    2. 焦点事件        1. onblur：失去焦点        2. onfocus:元素获得焦点。    3. 加载事件：        1. onload：一张页面或一幅图像完成加载。    4. 鼠标事件：        1. onmousedown    鼠标按钮被按下。        2. onmouseup    鼠标按键被松开。        3. onmousemove    鼠标被移动。        4. onmouseover    鼠标移到某元素之上。        5. onmouseout    鼠标从某元素移开。</code></pre><p>​            </p><pre><code>    5. 键盘事件：        1. onkeydown    某个键盘按键被按下。            2. onkeyup        某个键盘按键被松开。        3. onkeypress    某个键盘按键被按下并松开。    6. 选择和改变        1. onchange    域的内容被改变。        2. onselect    文本被选中。    7. 表单事件：        1. onsubmit    确认按钮被点击。        2. onreset    重置按钮被点击。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet(二)</title>
      <link href="/2019/01/04/servlet2/"/>
      <url>/2019/01/04/servlet2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/images/image.jpg" alt=""></p><p><img src="../images/image.jpg" alt="aaa"></p><h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><pre><code>1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0 注解配置6. Servlet的体系结构        Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法    {% HttpServlet.bmp %}    ![](/Servlet2/HttpServlet.bmp)    7. Servlet相关配置    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet入门</title>
      <link href="/2019/01/04/servlet1/"/>
      <url>/2019/01/04/servlet1/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. web相关概念回顾2. web服务器软件：Tomcat3. Servlet入门学习</code></pre><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人        * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称        * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。* 快速入门：    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;* 执行原理：    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法* Servlet中的生命周期方法：    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数 load-on-startup 元素标记容器是否应该在web应用程序启动的时候就加载这个servlet    (实例化并调用其init()方法)。它的值必须是一个整数，表示servlet被加载的先后顺序。          如果该元素的值为负数或者没有设置，则容器会当Servlet被请求时再加载。          如果值为正整数或者0时，表示容器在应用启动时就加载并初始化这个servlet，值越小，servlet的优先级           越高，就越先被加载。值相同时，容器就会自己选择顺序来加载。        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target({ElementType.TYPE})            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet {                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                String[] value() default {};//代表urlPatterns()属性配置                String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                WebInitParam[] initParams() default {};                boolean asyncSupported() default false;                String smallIcon() default &quot;&quot;;                String largeIcon() default &quot;&quot;;                String description() default &quot;&quot;;                String displayName() default &quot;&quot;;            }</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
