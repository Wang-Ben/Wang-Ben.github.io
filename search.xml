<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis入门</title>
      <link href="/2019/01/10/redis-bi-ji/"/>
      <url>/2019/01/10/redis-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. redis    1. 概念    2. 下载安装    3. 命令操作        1. 数据结构    4. 持久化操作    5. 使用Java客户端操作redis</code></pre><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库    1.1.什么是NOSQL        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。        1.1.1.    NOSQL和关系型数据库比较            优点：                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。            缺点：                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。                3）不提供关系型数据库对事务的处理。        1.1.2.    非关系型数据库的优势：            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。        1.1.3.    关系型数据库的优势：            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</code></pre><p>​            <img src="\images\1.关系型和非关系型数据库比较.bmp" alt=""><br>            1.1.4.    总结<br>                关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，<br>                让NoSQL数据库对关系型数据库的不足进行弥补。<br>                一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p><pre><code>    1.2.主流的NOSQL产品        •    键值(Key-Value)存储数据库                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。                 数据模型： 一系列键值对                优势： 快速查询                劣势： 存储的数据缺少结构化        •    列存储数据库                相关产品：Cassandra, HBase, Riak                典型应用：分布式的文件系统                数据模型：以列簇式存储，将同一列数据存在一起                优势：查找速度快，可扩展性强，更容易进行分布式扩展                劣势：功能相对局限        •    文档型数据库                相关产品：CouchDB、MongoDB                典型应用：Web应用（与Key-Value类似，Value是结构化的）                数据模型： 一系列键值对                优势：数据结构要求不严格                劣势： 查询性能不高，而且缺乏统一的查询语法        •    图形(Graph)数据库                相关数据库：Neo4J、InfoGrid、Infinite Graph                典型应用：社交网络                数据模型：图结构                优势：利用图结构相关算法。                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。    1.3 什么是Redis        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：            1) 字符串类型 string            2) 哈希类型 hash            3) 列表类型 list            4) 集合类型 set            5) 有序集合类型 sortedset        1.3.1 redis的应用场景            •    缓存（数据查询、短连接、新闻内容、商品内容等等）            •    聊天室的在线好友列表            •    任务队列。（秒杀、抢购、12306等等）            •    应用排行榜            •    网站访问统计            •    数据过期处理（可以精确到毫秒            •    分布式集群架构中的session分离2. 下载安装    1. 官网：https://redis.io    2. 中文网：http://www.redis.net.cn/    3. 解压直接可以使用：        * redis.windows.conf：配置文件        * redis-cli.exe：redis的客户端        * redis-server.exe：redis服务器端3. 命令操作    1. redis的数据结构：        * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构            * value的数据结构：                1) 字符串类型 string                2) 哈希类型 hash ： map格式                  3) 列表类型 list ： linkedlist格式。支持重复元素                4) 集合类型 set  ： 不允许重复元素                5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</code></pre><p>​    <img src="\images\2.redis数据结构.bmp" alt="">    </p><pre><code>    2. 字符串类型 string        1. 存储： set key value            127.0.0.1:6379&gt; set username zhangsan            OK        2. 获取： get key            127.0.0.1:6379&gt; get username            &quot;zhangsan&quot;        3. 删除： del key            127.0.0.1:6379&gt; del age            (integer) 1    3. 哈希类型 hash        1. 存储： hset key field value            127.0.0.1:6379&gt; hset myhash username lisi            (integer) 1            127.0.0.1:6379&gt; hset myhash password 123            (integer) 1        2. 获取：             * hget key field: 获取指定的field对应的值                127.0.0.1:6379&gt; hget myhash username                &quot;lisi&quot;            * hgetall key：获取所有的field和value                127.0.0.1:6379&gt; hgetall myhash                1) &quot;username&quot;                2) &quot;lisi&quot;                3) &quot;password&quot;                4) &quot;123&quot;        3. 删除： hdel key field            127.0.0.1:6379&gt; hdel myhash username            (integer) 1    4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）        1. 添加：            1. lpush key value: 将元素加入列表左表            2. rpush key value：将元素加入列表右边                127.0.0.1:6379&gt; lpush myList a                (integer) 1                127.0.0.1:6379&gt; lpush myList b                (integer) 2                127.0.0.1:6379&gt; rpush myList c                (integer) 3        2. 获取：            * lrange key start end ：范围获取                127.0.0.1:6379&gt; lrange myList 0 -1                1) &quot;b&quot;                2) &quot;a&quot;                3) &quot;c&quot;        3. 删除：            * lpop key： 删除列表最左边的元素，并将元素返回            * rpop key： 删除列表最右边的元素，并将元素返回</code></pre><p><img src="\images\3.列表list数据结构.bmp" alt=""></p><pre><code>    5. 集合类型 set ： 不允许重复元素        1. 存储：sadd key value            127.0.0.1:6379&gt; sadd myset a            (integer) 1            127.0.0.1:6379&gt; sadd myset a            (integer) 0        2. 获取：smembers key:获取set集合中所有元素            127.0.0.1:6379&gt; smembers myset            1) &quot;a&quot;        3. 删除：srem key value:删除set集合中的某个元素                127.0.0.1:6379&gt; srem myset a            (integer) 1    6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。        1. 存储：zadd key score value            127.0.0.1:6379&gt; zadd mysort 60 zhangsan            (integer) 1            127.0.0.1:6379&gt; zadd mysort 50 lisi            (integer) 1            127.0.0.1:6379&gt; zadd mysort 80 wangwu            (integer) 1        2. 获取：zrange key start end [withscores]            127.0.0.1:6379&gt; zrange mysort 0 -1            1) &quot;lisi&quot;            2) &quot;zhangsan&quot;            3) &quot;wangwu&quot;            127.0.0.1:6379&gt; zrange mysort 0 -1 withscores            1) &quot;zhangsan&quot;            2) &quot;60&quot;            3) &quot;wangwu&quot;            4) &quot;80&quot;            5) &quot;lisi&quot;            6) &quot;500&quot;        3. 删除：zrem key value            127.0.0.1:6379&gt; zrem mysort lisi            (integer) 1    7. 通用命令        1. keys * : 查询所有的键        2. type key ： 获取键对应的value的类型        3. del key：删除指定的key value4. 持久化    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。    2. redis持久化机制：        1. RDB：默认方式，不需要进行配置，默认就使用这种机制            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据            1. 编辑redis.windwos.conf文件                #   after 900 sec (15 min) if at least 1 key changed                save 900 1                #   after 300 sec (5 min) if at least 10 keys changed                save 300 10                #   after 60 sec if at least 10000 keys changed                save 60 10000            2. 重新启动redis服务器，并指定配置文件名称                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据            1. 编辑redis.windwos.conf文件                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）                # appendfsync always ： 每一次操作都进行持久化                appendfsync everysec ： 每隔一秒进行一次持久化                # appendfsync no     ： 不进行持久化5. Java客户端 Jedis    * Jedis: 一款java操作redis数据库的工具.    * 使用步骤：        1. 下载jedis的jar包        2. 使用            //1. 获取连接            Jedis jedis = new Jedis(&quot;localhost&quot;,6379);               //2. 操作               jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //3. 关闭连接            jedis.close();</code></pre><p>​        </p><pre><code>    * Jedis操作各种redis中的数据结构        1) 字符串类型 string            set            get             //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            //存储            jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //获取            String username = jedis.get(&quot;username&quot;);            System.out.println(username);            //可以使用setex()方法存储可以指定过期时间的 key value            jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对            //3. 关闭连接            jedis.close();        2) 哈希类型 hash ： map格式              hset            hget            hgetAll            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // 存储hash            jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);            jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);            jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);            // 获取hash            String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);            System.out.println(name);</code></pre><p>​<br>                // 获取hash的所有map中的数据<br>                Map&lt;String, String&gt; user = jedis.hgetAll(“user”);</p><pre><code>            // keyset            Set&lt;String&gt; keySet = user.keySet();            for (String key : keySet) {                //获取value                String value = user.get(key);                System.out.println(key + &quot;:&quot; + value);            }            //3. 关闭连接            jedis.close();        3) 列表类型 list ： linkedlist格式。支持重复元素            lpush / rpush            lpop / rpop            lrange start end : 范围获取             //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // list 存储            jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存            jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存            // list 范围获取            List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist);            // list 弹出            String element1 = jedis.lpop(&quot;mylist&quot;);//c            System.out.println(element1);            String element2 = jedis.rpop(&quot;mylist&quot;);//c            System.out.println(element2);            // list 范围获取            List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist2);            //3. 关闭连接            jedis.close();        4) 集合类型 set  ： 不允许重复元素            sadd            smembers:获取所有元素            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作</code></pre><p>​<br>                // set 存储<br>                jedis.sadd(“myset”,”java”,”php”,”c++”);</p><pre><code>            // set 获取            Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);            System.out.println(myset);            //3. 关闭连接            jedis.close();        5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序            zadd            zrange            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // sortedset 存储            jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);            jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);            jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);            // sortedset 获取            Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);            System.out.println(mysortedset);</code></pre><p>​<br>                //3. 关闭连接<br>                jedis.close();</p><p>​        </p><pre><code>    * jedis连接池： JedisPool        * 使用：            1. 创建JedisPool连接池对象            2. 调用方法 getResource()方法获取Jedis连接                //0.创建一个配置对象                JedisPoolConfig config = new JedisPoolConfig();                config.setMaxTotal(50);                config.setMaxIdle(10);                //1.创建Jedis连接池对象                JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379);                //2.获取连接                Jedis jedis = jedisPool.getResource();                //3. 使用                jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);</code></pre><p>​<br>                    //4. 关闭 归还到连接池中<br>                    jedis.close();</p><pre><code>        * 连接池工具类            public class JedisPoolUtils {                private static JedisPool jedisPool;                static{                    //读取配置文件                    InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);                    //创建Properties对象                    Properties pro = new Properties();                    //关联文件                    try {                        pro.load(is);                    } catch (IOException e) {                        e.printStackTrace();                    }                    //获取数据，设置到JedisPoolConfig中                    JedisPoolConfig config = new JedisPoolConfig();                    config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));                    config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));                    //初始化JedisPool                    jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</code></pre><p>​<br>​<br>                    }</p><p>​<br>                    /**</p><pre><code>                 * 获取连接方法                 */                public static Jedis getJedis(){                    return jedisPool.getResource();                }            }</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：    1. 提供index.html页面，页面中有一个省份 下拉列表    2. 当 页面加载完成后 发送ajax请求，加载所有省份* 注意：使用redis缓存一些不经常发生变化的数据。    * 数据库的数据一旦发生改变，则需要更新缓存。        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入        * 在service对应的增删改方法中，将redis数据删除。</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery入门</title>
      <link href="/2019/01/06/jquery-ji-chu-bi-ji/"/>
      <url>/2019/01/06/jquery-ji-chu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>1. JQuery 基础：    1. 概念    2. 快速入门    3. JQuery对象和JS对象区别与转换    4. 选择器    5. DOM操作    6. 案例</code></pre><h1 id="JQuery-基础："><a href="#JQuery-基础：" class="headerlink" title="JQuery 基础："></a>JQuery 基础：</h1><pre><code>1. 概念： 一个JavaScript框架。简化JS开发    * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。    * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已2. 快速入门    1. 步骤：        1. 下载JQuery            * 目前jQuery有三个大版本：                1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，                     功能不再新增。因此一般项目来说，使用1.x版本就可以了，                     最终版本：1.12.4 (2016年5月20日)                2.x：不兼容ie678，很少有人使用，官方只做BUG维护，                     功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，                     最终版本：2.2.4 (2016年5月20日)                3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，                     一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。                     目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）            * jquery-xxx.js 与 jquery-xxx.min.js区别：                1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些                2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快        2. 导入JQuery的js文件：导入min.js文件        3. 使用            var div1 = $(&quot;#div1&quot;);               alert(div1.html());3. JQuery对象和JS对象区别与转换    1. JQuery对象在操作时，更加方便。    2. JQuery对象和js对象方法不通用的.    3. 两者相互转换        * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引)        * js -- &gt; jq : $(js对象)4. 选择器：筛选具有相似特征的元素(标签)    1. 基本操作学习：        1. 事件绑定            //1.获取b1按钮            $(&quot;#b1&quot;).click(function(){                alert(&quot;abc&quot;);            });        2. 入口函数             $(function () {                });             window.onload  和 $(function) 区别                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉                 * $(function)可以定义多次的。        3. 样式控制：css方法             // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);              $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);    2. 分类        1. 基本选择器            1. 标签选择器（元素选择器）                * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素            2. id选择器                 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素            3. 类选择器                * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素            4. 并集选择器：                * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素        2. 层级选择器            1. 后代选择器                * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素                    2. 子选择器                * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素        3. 属性选择器            1. 属性名称选择器                 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器            2. 属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器            3. 复合属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器        4. 过滤选择器            1. 首元素选择器                 * 语法： :first 获得选择的元素中的第一个元素            2. 尾元素选择器                 * 语法： :last 获得选择的元素中的最后一个元素            3. 非元素选择器                * 语法： :not(selector) 不包括指定内容的元素            4. 偶数选择器                * 语法： :even 偶数，从 0 开始计数            5. 奇数选择器                * 语法： :odd 奇数，从 0 开始计数            6. 等于索引选择器                * 语法： :eq(index) 指定索引元素            7. 大于索引选择器                 * 语法： :gt(index) 大于指定索引元素            8. 小于索引选择器                 * 语法： :lt(index) 小于指定索引元素            9. 标题选择器                * 语法： :header 获得标题（h1~h6）元素，固定写法        5. 表单过滤选择器            1. 可用元素选择器                 * 语法： :enabled 获得可用元素            2. 不可用元素选择器                 * 语法： :disabled 获得不可用元素            3. 选中选择器                 * 语法： :checked 获得单选/复选框选中的元素            4. 选中选择器                 * 语法： :selected 获得下拉框选中的元素5. DOM操作    1. 内容操作        1. html(): 获取/设置元素的标签体内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;        2. text(): 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容        3. val()： 获取/设置元素的value属性值    2. 属性操作        1. 通用属性操作            1. attr(): 获取/设置元素的属性            2. removeAttr():删除属性            3. prop():获取/设置元素的属性            4. removeProp():删除属性            * attr和prop区别？                1. 如果操作的是元素的固有属性，则建议使用prop                2. 如果操作的是元素自定义的属性，则建议使用attr        2. 对class属性操作            1. addClass():添加class属性值            2. removeClass():删除class属性值            3. toggleClass():切换class属性                * toggleClass(&quot;one&quot;):                     * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。  如果元素对象上不存在class=&quot;one&quot;，则添加            4. css():    3. CRUD操作:        1. append():父元素将子元素追加到末尾            * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾        2. prepend():父元素将子元素追加到开头            * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头        3. appendTo():            * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾        4. prependTo()：            * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头        5. after():添加元素到元素后边            * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系        6. before():添加元素到元素前边            * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        7. insertAfter()            * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系        8. insertBefore()            * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        9. remove():移除元素            * 对象.remove():将对象删除掉        10. empty():清空元素的所有后代元素。            * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点6. 案例</code></pre><p>​            </p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery高级</title>
      <link href="/2019/01/06/jquery-gao-ji-bi-ji/"/>
      <url>/2019/01/06/jquery-gao-ji-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><pre><code>1. JQuery 高级    1. 动画    2. 遍历    3. 事件绑定    4. 案例    5. 插件</code></pre><h2 id="JQuery-高级"><a href="#JQuery-高级" class="headerlink" title="JQuery 高级"></a>JQuery 高级</h2><pre><code>1. 动画    1. 三种方式显示和隐藏元素        1. 默认显示和隐藏方式            1. show([speed,[easing],[fn]])                1. 参数：                    1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)                    2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;                        * swing：动画执行时效果是 先慢，中间快，最后又慢                        * linear：动画执行时速度是匀速的                    3. fn：在动画完成时执行的函数，每个元素执行一次。            2. hide([speed,[easing],[fn]])            3. toggle([speed],[easing],[fn])        2. 滑动显示和隐藏方式            1. slideDown([speed],[easing],[fn])            2. slideUp([speed,[easing],[fn]])            3. slideToggle([speed],[easing],[fn])        3. 淡入淡出显示和隐藏方式            1. fadeIn([speed],[easing],[fn])            2. fadeOut([speed],[easing],[fn])            3. fadeToggle([speed,[easing],[fn]])2. 遍历    1. js的遍历方式        * for(初始化值;循环结束条件;步长)    2. jq的遍历方式        1. jq对象.each(callback)            1. 语法：                jquery对象.each(function(index,element){});                    * index:就是元素在集合中的索引                    * element：就是集合中的每一个元素对象                    * this：集合中的每一个元素对象            2. 回调函数返回值：                * true:如果当前function返回为false，则结束循环(break)。                * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)        2. $.each(object, [callback])        3. for..of: jquery 3.0 版本之后提供的方式            for(元素对象 of 容器对象)3. 事件绑定    1. jquery标准的绑定方式        * jq对象.事件方法(回调函数)；        * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。            * 表单对象.submit();//让表单提交    2. on绑定事件/off解除绑定        * jq对象.on(&quot;事件名称&quot;,回调函数)        * jq对象.off(&quot;事件名称&quot;)            * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑    3. 事件切换：toggle        * jq对象.toggle(fn1,fn2...)            * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....        * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。             &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;4. 案例    1. 广告显示和隐藏        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt;            &lt;style&gt;                #content{width:100%;height:500px;background:#999}            &lt;/style&gt;            &lt;!--引入jquery--&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script&gt;                /*                    需求：                        1. 当页面加载完，3秒后。自动显示广告                        2. 广告显示5秒后，自动消失。                    分析：                        1. 使用定时器来完成。setTimeout (执行一次定时器)                        2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display                        3. 使用  show/hide方法来完成广告的显示                 */                //入口函数，在页面加载完成之后，定义定时器，调用这两个方法                $(function () {                   //定义定时器，调用adShow方法 3秒后执行一次                   setTimeout(adShow,3000);                   //定义定时器，调用adHide方法，8秒后执行一次                    setTimeout(adHide,8000);                });                //显示广告                function adShow() {                    //获取广告div，调用显示方法                    $(&quot;#ad&quot;).show(&quot;slow&quot;);                }                //隐藏广告                function adHide() {                    //获取广告div，调用隐藏方法                    $(&quot;#ad&quot;).hide(&quot;slow&quot;);                }</code></pre><p>​<br>​<br>                <br>            <br>            <body><br>            <!-- 整体的DIV --><br>            <div><br>                <!-- 广告DIV --><br>                <div id="ad" style="display: none;"><br>                    <img style="width:100%" src="../img/adv.jpg"><br>                </div></div></body></p><pre><code>            &lt;!-- 下方正文部分 --&gt;            &lt;div id=&quot;content&quot;&gt;                正文部分            &lt;/div&gt;        &lt;/div&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 抽奖        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;jquery案例之抽奖&lt;/title&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script language=&#39;javascript&#39; type=&#39;text/javascript&#39;&gt;                /*                    分析：                        1. 给开始按钮绑定单击事件                            1.1 定义循环定时器                            1.2 切换小相框的src属性                                * 定义数组，存放图片资源路径                                * 生成随机数。数组索引</code></pre><p>​            </p><pre><code>                        2. 给结束按钮绑定单击事件                            1.1 停止定时器                            1.2 给大相框设置src属性                 */                var imgs = [&quot;../img/man00.jpg&quot;,                            &quot;../img/man01.jpg&quot;,                            &quot;../img/man02.jpg&quot;,                            &quot;../img/man03.jpg&quot;,                            &quot;../img/man04.jpg&quot;,                            &quot;../img/man05.jpg&quot;,                            &quot;../img/man06.jpg&quot;,                            ];                var startId;//开始定时器的id                var index;//随机角标                $(function () {                    //处理按钮是否可以使用的效果                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</code></pre><p>​<br>                       //1. 给开始按钮绑定单击事件<br>                        $(“#startID”).click(function () {<br>                            // 1.1 定义循环定时器 20毫秒执行一次<br>                            startId = setInterval(function () {<br>                                //处理按钮是否可以使用的效果<br>                                $(“#startID”).prop(“disabled”,true);<br>                                $(“#stopID”).prop(“disabled”,false);</p><p>​<br>                                //1.2生成随机角标 0-6<br>                                index = Math.floor(Math.random() <em> 7);//0.000–0.999 –&gt; </em> 7 –&gt; 0.0—–6.9999<br>                                //1.3设置小相框的src属性<br>                                $(“#img1ID”).prop(“src”,imgs[index]);</p><pre><code>                        },20);                    });</code></pre><p>​<br>                        //2. 给结束按钮绑定单击事件<br>                        $(“#stopID”).click(function () {<br>                            //处理按钮是否可以使用的效果<br>                            $(“#startID”).prop(“disabled”,false);<br>                            $(“#stopID”).prop(“disabled”,true);</p><p>​<br>                           // 1.1 停止定时器<br>                            clearInterval(startId);<br>                           // 1.2 给大相框设置src属性<br>                            $(“#img2ID”).prop(“src”,imgs[index]).hide();<br>                            //显示1秒之后<br>                            $(“#img2ID”).show(1000);<br>                        });<br>                    });</p><p>​<br>​<br>​<br>                </p><pre><code>        &lt;/head&gt;        &lt;body&gt;        &lt;!-- 小像框 --&gt;        &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;            &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;        &lt;/div&gt;        &lt;!-- 大像框 --&gt;        &lt;div                style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;            &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;        &lt;/div&gt;        &lt;!-- 开始按钮 --&gt;        &lt;input                id=&quot;startID&quot;                type=&quot;button&quot;                value=&quot;点击开始&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;        &lt;!-- 停止按钮 --&gt;        &lt;input                id=&quot;stopID&quot;                type=&quot;button&quot;                value=&quot;点击停止&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;</code></pre><p>​<br>            <br>            </p><pre><code>5. 插件：增强JQuery的功能    1. 实现方式：        1. $.fn.extend(object)             * 增强通过Jquery获取的对象的功能  $(&quot;#id&quot;)        2. $.extend(object)            * 增强JQeury对象自身的功能  $/jQuery</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级</title>
      <link href="/2019/01/05/javascript-gao-ji-bi-ji/"/>
      <url>/2019/01/05/javascript-gao-ji-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. JavaScript：    1. ECMAScript：    2. BOM：    3. DOM：        1. 事件</code></pre><h2 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h2><pre><code>* 功能：控制html文档的内容* 获取页面标签(元素)对象：Element    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象* 操作Element对象：    1. 修改属性值：        1. 明确获取的对象是哪一个？        2. 查看API文档，找其中有哪些属性可以设置    2. 修改标签体内容：        * 属性：innerHTML        1. 获取元素对象        2. 使用innerHTML属性修改标签体内容</code></pre><h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2><pre><code>* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。    * 造句：  xxx被xxx,我就xxx        * 我方水晶被摧毁后，我就责备对友。        * 敌方水晶被摧毁后，我就夸奖自己。* 如何绑定事件    1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码        1. 事件：onclick--- 单击事件    2. 通过js获取元素对象，指定事件属性，设置一个函数    * 代码：        &lt;body&gt;            &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;  onclick=&quot;fun();&quot;&gt;            &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt;            &lt;script&gt;                function fun(){                    alert(&#39;我被点了&#39;);                    alert(&#39;我又被点了&#39;);                }                function fun2(){                    alert(&#39;咋老点我？&#39;);                }                //1.获取light2对象                var light2 = document.getElementById(&quot;light2&quot;);                //2.绑定事件                light2.onclick = fun2;            &lt;/script&gt;        &lt;/body&gt;</code></pre><p>​        </p><pre><code>* 案例1：电灯开关    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;电灯开关&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt;    &lt;script&gt;        /*            分析：                1.获取图片对象                2.绑定单击事件                3.每次点击切换图片                    * 规则：                        * 如果灯是开的 on,切换图片为 off                        * 如果灯是关的 off,切换图片为 on                    * 使用标记flag来完成         */        //1.获取图片对象        var light = document.getElementById(&quot;light&quot;);        var flag = false;//代表灯是灭的。 off图片        //2.绑定单击事件        light.onclick = function(){            if(flag){//判断如果灯是开的，则灭掉                light.src = &quot;img/off.gif&quot;;                flag = false;            }else{                //如果灯是灭的，则打开                light.src = &quot;img/on.gif&quot;;                flag = true;            }        }    &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><p><img src="..\images\bom对象介绍.png" alt=""></p><p><img src="\images\bom对象介绍.png" alt="">    </p><ol><li><p>概念：Browser Object Model 浏览器对象模型</p><pre><code>     * 将浏览器的各个组成部分封装成对象。</code></pre></li></ol><pre><code>2. 组成：    * Window：窗口对象    * Navigator：浏览器对象    * Screen：显示器屏幕对象    * History：历史记录对象    * Location：地址栏对象3. Window：窗口对象    1. 创建（详见4.特点）    2. 方法         1. 与弹出框有关的方法：            alert()    显示带有一段消息和一个确认按钮的警告框。            confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。                * 如果用户点击确定按钮，则方法返回true                * 如果用户点击取消按钮，则方法返回false            prompt()    显示可提示用户输入的对话框。                * 返回值：获取用户输入的值         2. 与打开关闭有关的方法：            close()    关闭浏览器窗口。                * 谁调用我 ，我关谁            open()    打开一个新的浏览器窗口                * 返回新的Window对象         3. 与定时器有关的方式            setTimeout()    在指定的毫秒数后调用函数或计算表达式。                * 参数：                    1. js代码或者方法对象                    2. 毫秒值                * 返回值：唯一标识，用于取消定时器            clearTimeout()    取消由 setTimeout() 方法设置的 timeout。            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。            clearInterval()    取消由 setInterval() 设置的 timeout。    3. 属性：        1. 获取其他BOM对象：            history            location            Navigator            Screen:            例: var h1 = window.history;                var h2 =history;(window可省略)        2. 获取DOM对象            document（同上）    4. 特点        * Window对象不需要创建可以直接使用 window使用。 window.方法名();        * window引用可以省略。  方法名();            例：alert();4. Location：地址栏对象    1. 创建(获取)：        1. window.location        2. location    2. 方法：        * reload()    重新加载当前文档。刷新    3. 属性        * href    设置或返回完整的 URL。5. History：历史记录对象    1. 创建(获取)：        1. window.history        2. history    2. 方法：        * back()    加载 history 列表中的前一个 URL。        * forward()    加载 history 列表中的下一个 URL。        * go(参数)    加载 history 列表中的某个具体页面。            * 参数：                * 正数：前进几个历史记录                * 负数：后退几个历史记录    3. 属性：        * length    返回当前窗口历史列表中的 URL 数量。</code></pre><h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><p><img src="..\images\DOM树.bmp" alt=""></p><p><img src="\images\DOM树.bmp" alt=""></p><pre><code>* 概念： Document Object Model 文档对象模型    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作* W3C DOM 标准被分为 3 个不同的部分：    * 核心 DOM - 针对任何结构化文档的标准模型        * Document：文档对象        * Element：元素对象        * Attribute：属性对象        * Text：文本对象        * Comment:注释对象        * Node：节点对象，其他5个的父对象    * XML DOM - 针对 XML 文档的标准模型    * HTML DOM - 针对 HTML 文档的标准模型* 核心DOM模型：    * Document：文档对象        1. 创建(获取)：在html dom模型中可以使用window对象来获取            1. window.document            2. document        2. 方法：            1. 获取Element对象：                1. getElementById()    ： 根据id属性值获取元素对象。id属性值一般唯一                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组            2. 创建其他DOM对象：                createAttribute(name)                createComment()                createElement()                createTextNode()        3. 属性    * Element：元素对象        1. 获取/创建：通过document来获取和创建        2. 方法：            1. removeAttribute()：删除属性            2. setAttribute()：设置属性    * Node：节点对象，其他5个的父对象        * 特点：所有dom对象都可以被认为是一个节点        * 方法：            * CRUD dom树：                * appendChild()：向节点的子节点列表的结尾添加新的子节点。                * removeChild()    ：删除（并返回）当前节点的指定子节点。                * replaceChild()：用新节点替换一个子节点。        * 属性：            * parentNode 返回节点的父节点。* HTML DOM    1. 标签体的设置和获取：innerHTML    2. 使用html元素对象的属性    3. 控制元素样式        1. 使用元素的style属性来设置            如：                 //修改样式方式1                div1.style.border = &quot;1px solid red&quot;;                div1.style.width = &quot;200px&quot;;                //font-size--&gt; fontSize                div1.style.fontSize = &quot;20px&quot;;        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</code></pre><h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><pre><code>* 概念：某些组件被执行了某些操作后，触发某些代码的执行。        * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了    * 事件源：组件。如： 按钮 文本输入框...    * 监听器：代码。    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。* 常见的事件：    1. 点击事件：        1. onclick：单击事件        2. ondblclick：双击事件    2. 焦点事件        1. onblur：失去焦点        2. onfocus:元素获得焦点。    3. 加载事件：        1. onload：一张页面或一幅图像完成加载。    4. 鼠标事件：        1. onmousedown    鼠标按钮被按下。        2. onmouseup    鼠标按键被松开。        3. onmousemove    鼠标被移动。        4. onmouseover    鼠标移到某元素之上。        5. onmouseout    鼠标从某元素移开。</code></pre><p>​            </p><pre><code>    5. 键盘事件：        1. onkeydown    某个键盘按键被按下。            2. onkeyup        某个键盘按键被松开。        3. onkeypress    某个键盘按键被按下并松开。    6. 选择和改变        1. onchange    域的内容被改变。        2. onselect    文本被选中。    7. 表单事件：        1. onsubmit    确认按钮被点击。        2. onreset    重置按钮被点击。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/2019/01/05/javascript-ji-chu-bi-ji/"/>
      <url>/2019/01/05/javascript-ji-chu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. JavaScript基础</code></pre><h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><pre><code>* 概念：    一门客户端脚本语言    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了* 功能：    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。* JavaScript发展史：    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--    ，后来更名为：ScriptEase    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript    3. 1996年，微软抄袭JavaScript开发出JScript语言    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)* ECMAScript：客户端脚本语言的标准    1. 基本语法：        1. 与html结合方式            1. 内部JS：                * 定义&lt;script&gt;，标签体内容就是js代码            2. 外部JS：                * 定义&lt;script&gt;，通过src属性引入外部的js文件            * 注意：                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。                2. &lt;script&gt;可以定义多个。        2. 注释            1. 单行注释：//注释内容            2. 多行注释：/*注释内容*/        3. 数据类型：            1. 原始数据类型(基本数据类型)：                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &#39;abc&#39;                3. boolean: true和false                4. null：一个对象为空的占位符                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined            2. 引用数据类型：对象        4. 变量            * 变量：一小块存储数据的内存空间            * Java语言是强类型语言，而JavaScript是弱类型语言。                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。            * 语法：                * var 变量名 = 初始化值;            * typeof运算符：获取变量的类型。                * 注：null运算后得到的是object        5. 运算符            1. 一元运算符：只有一个运算数的运算符                ++，-- ， +(正号)                  * ++ --: 自增(自减)                    * ++(--) 在前，先自增(自减)，再运算                    * ++(--) 在后，先运算，再自增(自减)                * +(-)：正负号                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换                    * 其他类型转number：                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）                        * boolean转number：true转为1，false转为0            2. 算数运算符                + - * / % ...            3. 赋值运算符                = += -+....            4. 比较运算符                &gt; &lt; &gt;= &lt;= == ===(全等于)                * 比较方式                  1. 类型相同：直接比较                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。                  2. 类型不同：先进行类型转换，再比较                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false            5. 逻辑运算符                &amp;&amp; || !                * 其他类型转boolean：                   1. number：0或NaN为假，其他为真                   2. string：除了空字符串(&quot;&quot;)，其他都是true                   3. null&amp;undefined:都是false                   4. 对象：所有对象都为true            6. 三元运算符                ? : 表达式                var a = 3;                var b = 4;                var c = a &gt; b ? 1:0;                * 语法：                    * 表达式? 值1:值2;                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；        6. 流程控制语句：            1. if...else...            2. switch:                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)                    * switch(变量):                        case 值:                * 在JS中,switch语句可以接受任意的原始数据类型            3. while            4. do...while            5. for        7. JS特殊语法：            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)            2. 变量的定义使用var关键字，也可以不使用                * 用： 定义的变量是局部变量                * 不用：定义的变量是全局变量(不建议)        8. 练习：99乘法表        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;99乘法表&lt;/title&gt;            &lt;style&gt;                td{                    border: 1px solid;                }            &lt;/style&gt;            &lt;script&gt;                document.write(&quot;&lt;table  align=&#39;center&#39;&gt;&quot;);</code></pre><p>​<br>                    //1.完成基本的for循环嵌套，展示乘法表<br>                    for (var i = 1; i &lt;= 9 ; i++) {<br>                        document.write(“<tr>“);<br>                        for (var j = 1; j &lt;=i ; j++) {<br>                            document.write(“<td>“);</td></tr></p><pre><code>                        //输出  1 * 1 = 1                        document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);                        document.write(&quot;&lt;/td&gt;&quot;);                    }                    /*//输出换行                    document.write(&quot;&lt;br&gt;&quot;);*/                    document.write(&quot;&lt;/tr&gt;&quot;);                }                //2.完成表格嵌套                document.write(&quot;&lt;/table&gt;&quot;);            &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 基本对象：        1. Function：函数(方法)对象            1. 创建：                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧                2.                     function 方法名称(形式参数列表){                        方法体                    }                3.                    var 方法名 = function(形式参数列表){                        方法体                   }            2. 方法：            3. 属性：                length:代表形参的个数            4. 特点：                1. 方法定义是，形参的类型不用写,返回值类型也不写。                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数            5. 调用：                方法名称(实际参数列表);        2. Array:数组对象            1. 创建：                1. var arr = new Array(元素列表);                2. var arr = new Array(默认长度);                3. var arr = [元素列表];            2. 方法                join(参数):将数组中的元素按照指定的分隔符拼接为字符串                push()    向数组的末尾添加一个或更多元素，并返回新的长度。            3. 属性                length:数组的长度            4. 特点：                1. JS中，数组元素的类型可变的。                2. JS中，数组长度可变的。        3. Boolean        4. Date：日期对象            1. 创建：                var date = new Date();            2. 方法：                toLocaleString()：返回当前date对象对应的时间本地字符串格式                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差        5. Math：数学对象            1. 创建：                * 特点：Math对象不用创建，直接使用。  Math.方法名();            2. 方法：                random():返回 0 ~ 1 之间的随机数。 含0不含1                ceil(x)：对数进行上舍入。                floor(x)：对数进行下舍入。                round(x)：把数四舍五入为最接近的整数。            3. 属性：                PI        6. Number        7. String        8. RegExp：正则表达式对象            1. 正则表达式：定义字符串的组成规则。                1. 单个字符:[]                    如： [a] [ab] [a-zA-Z0-9_]                    * 特殊符号代表特殊含义的单个字符:                        \d:单个数字字符 [0-9]                        \w:单个单词字符[a-zA-Z0-9_]                2. 量词符号：                    ?：表示出现0次或1次                    *：表示出现0次或多次                    +：出现1次或多次                    {m,n}:表示 m&lt;= 数量 &lt;= n                        * m如果缺省： {,n}:最多n次                        * n如果缺省：{m,} 最少m次                3. 开始结束符号                    * ^:开始                    * $:结束            2. 正则对象：                1. 创建                    1. var reg = new RegExp(&quot;正则表达式&quot;);                    2. var reg = /正则表达式/;                2. 方法                        1. test(参数):验证指定的字符串是否符合正则定义的规范            9. Global            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();            2. 方法：                encodeURI():url编码                decodeURI():url解码                encodeURIComponent():url编码,编码的字符更多                decodeURIComponent():url解码                parseInt():将字符串转为数字                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number                isNaN():判断一个值是否是NaN                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。            3. URL编码               你好世界 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2* BOM* DOM</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml&amp;jsonp</title>
      <link href="/2019/01/05/xml-bi-ji/"/>
      <url>/2019/01/05/xml-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. XML    1. 概念    2. 语法    3. 解析</code></pre><h2 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h2><pre><code>1. 概念：Extensible Markup Language 可扩展标记语言    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;    * 功能        * 存储数据            1. 配置文件            2. 在网络中传输    * xml与html的区别        1. xml标签都是自定义的，html标签是预定义。        2. xml的语法严格，html语法松散        3. xml是存储数据的，html是展示数据    * w3c:万维网联盟2. 语法：    * 基本语法：        1. xml文档的后缀名 .xml        2. xml第一行必须定义为文档声明        3. xml文档中有且仅有一个根标签        4. 属性值必须使用引号(单双都可)引起来        5. 标签必须正确关闭        6. xml标签名称区分大小写    * 快速入门：        &lt;?xml version=&#39;1.0&#39; ?&gt;        &lt;users&gt;            &lt;user id=&#39;1&#39;&gt;                &lt;name&gt;zhangsan&lt;/name&gt;                &lt;age&gt;23&lt;/age&gt;                &lt;gender&gt;male&lt;/gender&gt;                &lt;br/&gt;            &lt;/user&gt;            &lt;user id=&#39;2&#39;&gt;                &lt;name&gt;lisi&lt;/name&gt;                &lt;age&gt;24&lt;/age&gt;                &lt;gender&gt;female&lt;/gender&gt;            &lt;/user&gt;        &lt;/users&gt;    * 组成部分：        1. 文档声明            1. 格式：&lt;?xml 属性列表 ?&gt;            2. 属性列表：                * version：版本号，必须的属性                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1                * standalone：是否独立                    * 取值：                        * yes：不依赖其他文件                        * no：依赖其他文件        2. 指令(了解)：结合css的            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;        3. 标签：标签名称自定义的            * 规则：                * 名称可以包含字母、数字以及其他的字符                 * 名称不能以数字或者标点符号开始                 * 名称不能以字母 xml（或者 XML、Xml 等等）开始                 * 名称不能包含空格         4. 属性：            id属性值唯一        5. 文本：            * CDATA区：在该区域中的数据会被原样展示                * 格式：  &lt;![CDATA[ 数据 ]]&gt;</code></pre><p>​    <img src="\images\约束.bmp" alt=""></p><p>​            </p><pre><code>        * 约束：规定xml文档的书写规则            * 作为框架的使用者(程序员)：                1. 能够在xml中引入约束文档                2. 能够简单的读懂约束文档        * 分类：            1. DTD:一种简单的约束技术            2. Schema:一种复杂的约束技术        * DTD：            * 引入dtd文档到xml文档中                * 内部dtd：将约束规则定义在xml文档中                * 外部dtd：将约束的规则定义在外部的dtd文件中                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;        * Schema:            * 引入：                1.填写xml文档的根元素                2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;                4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot;             &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                xmlns=&quot;http://www.itcast.cn/xml&quot;                xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;</code></pre><p>​    </p><pre><code>3. 解析：操作xml文档，将文档中的数据读取到内存中    * 操作xml文档        1. 解析(读取)：将文档中的数据读取到内存中        2. 写入：将内存中的数据保存到xml文档中。持久化的存储    * 解析xml的方式：        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树            * 优点：操作方便，可以对文档进行CRUD的所有操作            * 缺点：占内存        2. SAX：逐行读取，基于事件驱动的。            * 优点：不占内存。            * 缺点：只能读取，不能增删改</code></pre><p>​        </p><pre><code>    * xml常见的解析器：        1. JAXP：sun公司提供的解析器，支持dom和sax两种思想        2. DOM4J：一款非常优秀的解析器        3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        4. PULL：Android操作系统内置的解析器，sax方式的。    * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        * 快速入门：            * 步骤：                1. 导入jar包                2. 获取Document对象                3. 获取对应的标签Element对象                4. 获取数据        * 代码：             //2.1获取student.xml的path            String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();            //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);            //3.获取元素对象 Element            Elements elements = document.getElementsByTag(&quot;name&quot;);            System.out.println(elements.size());            //3.1获取第一个name的Element对象            Element element = elements.get(0);            //3.2获取数据            String name = element.text();            System.out.println(name);    * 对象的使用：        1. Jsoup：工具类，可以解析html或xml文档，返回Document            * parse：解析html或xml文档，返回Document                * parse​(File in, String charsetName)：解析xml或html文件的。                * parse​(String html)：解析xml或html字符串                * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象        2. Document：文档对象。代表内存中的dom树            * 获取Element对象                * getElementById​(String id)：根据id属性值获取唯一的element对象                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合        3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用        4. Element：元素对象            1. 获取子元素对象                * getElementById​(String id)：根据id属性值获取唯一的element对象                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合            2. 获取属性值                * String attr(String key)：根据属性名称获取属性值            3. 获取文本内容                * String text():获取文本内容                * String html():获取标签体的所有内容(包括字标签的字符串内容)        5. Node：节点对象            * 是Document和Element的父类</code></pre><p>​            </p><pre><code>    * 快捷查询方式：        1. selector:选择器            * 使用的方法：Elements    select(String cssQuery)                * 语法：参考Selector类中定义的语法        2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言            * 使用Jsoup的Xpath需要额外导入jar包。            * 查询w3cshool参考手册，使用xpath的语法完成查询            * 代码：                //1.获取student.xml的path                String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();                //2.获取Document对象                Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);                //3.根据document对象，创建JXDocument对象                JXDocument jxDocument = new JXDocument(document);                //4.结合xpath语法查询                //4.1查询所有student标签                List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);                for (JXNode jxNode : jxNodes) {                    System.out.println(jxNode);                }                System.out.println(&quot;--------------------&quot;);                //4.2查询所有student标签下的name标签                List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);                for (JXNode jxNode : jxNodes2) {                    System.out.println(jxNode);                }                System.out.println(&quot;--------------------&quot;);                //4.3查询student标签下带有id属性的name标签                List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);                for (JXNode jxNode : jxNodes3) {                    System.out.println(jxNode);                }                System.out.println(&quot;--------------------&quot;);                //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast                List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&#39;itcast&#39;]&quot;);                for (JXNode jxNode : jxNodes4) {                    System.out.println(jxNode);                }</code></pre>]]></content>
      
      
      <categories>
          
          <category> xml&amp;jsonp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> jsonp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet(二)</title>
      <link href="/2019/01/04/servlet2/"/>
      <url>/2019/01/04/servlet2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="/images/image.jpg" alt=""></p><p><img src="../images/image.jpg" alt="aaa"></p><h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><pre><code>1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0 注解配置6. Servlet的体系结构        Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法    {% HttpServlet.bmp %}    ![](/Servlet2/HttpServlet.bmp)    7. Servlet相关配置    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2019/01/04/html-css-ke-tang-bi-ji/"/>
      <url>/2019/01/04/html-css-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率3. CSS的使用：CSS与html结合方式    1. 内联样式         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;    2. 内部样式        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div{                    color:blue;                }            &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;    3. 外部样式        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div{                    color:green;                }            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 {            属性名1:属性值1;            属性名2:属性值2;            ...        }    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；5. 选择器：筛选具有相似特征的元素    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值{}            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称{}                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值{}                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *{}            2. 并集选择器：                * 选择器1,选择器2{}            3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2{}            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2{}            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]{}            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态{}                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;注册页面&lt;/title&gt;    &lt;style&gt;        *{            margin: 0px;            padding: 0px;            box-sizing: border-box;        }        body{            background: url(&quot;img/register_bg.png&quot;) no-repeat center;            padding-top: 25px;        }        .rg_layout{            width: 900px;            height: 500px;            border: 8px solid #EEEEEE;            background-color: white;            /*让div水平居中*/            margin: auto;        }        .rg_left{            /*border: 1px solid red;*/            float: left;            margin: 15px;        }        .rg_left &gt; p:first-child{            color:#FFD026;            font-size: 20px;        }        .rg_left &gt; p:last-child{            color:#A6A6A6;            font-size: 20px;        }</code></pre><p>​<br>            .rg_center{<br>                float: left;<br>               /<em> border: 1px solid red;</em>/</p><pre><code>        }        .rg_right{            /*border: 1px solid red;*/            float: right;            margin: 15px;        }        .rg_right &gt; p:first-child{            font-size: 15px;        }        .rg_right p a {            color:pink;        }        .td_left{            width: 100px;            text-align: right;            height: 45px;        }        .td_right{            padding-left: 50px ;        }        #username,#password,#email,#name,#tel,#birthday,#checkcode{            width: 251px;            height: 32px;            border: 1px solid #A6A6A6 ;            /*设置边框圆角*/            border-radius: 5px;            padding-left: 10px;        }        #checkcode{            width: 110px;        }        #img_check{            height: 32px;            vertical-align: middle;        }        #btn_sub{            width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026 ;        }    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;div class=&quot;rg_layout&quot;&gt;        &lt;div class=&quot;rg_left&quot;&gt;            &lt;p&gt;新用户注册&lt;/p&gt;            &lt;p&gt;USER REGISTER&lt;/p&gt;        &lt;/div&gt;        &lt;div class=&quot;rg_center&quot;&gt;            &lt;div class=&quot;rg_form&quot;&gt;                &lt;!--定义表单 form--&gt;                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                            &lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;</code></pre><p>​<br>                            <tr><br>                                <td colspan="2" align="center"><input type="submit" id="btn_sub" value="注册"></td><br>                            </tr><br>                        </p><pre><code>                &lt;/form&gt;</code></pre><p>​<br>                </p><pre><code>        &lt;/div&gt;        &lt;div class=&quot;rg_right&quot;&gt;            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;</code></pre><p>​<br>        </p><p>​<br>        <br>        </p>]]></content>
      
      
      <categories>
          
          <category> 前端入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap入门</title>
      <link href="/2019/01/04/bootstrap-bi-ji/"/>
      <url>/2019/01/04/bootstrap-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Bootstrap："><a href="#Bootstrap：" class="headerlink" title="Bootstrap："></a>Bootstrap：</h2><pre><code>1. 概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。    * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。    * 好处：        1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。        2. 响应式布局。            * 同一套页面可以兼容不同分辨率的设备。2. 快速入门    1. 下载Bootstrap    2. 在项目中将这三个文件夹复制    3. 创建html页面，引入必要的资源文件    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;        &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;        &lt;!-- Bootstrap --&gt;        &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</code></pre><p>​<br>            <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --><br>            <script src="js/jquery-3.2.1.min.js"></script><br>            <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --><br>            <script src="js/bootstrap.min.js"></script><br>        <br>        <body><br>        <h1>你好，世界！</h1></body></p><pre><code>    &lt;/body&gt;    &lt;/html&gt;</code></pre><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>* 同一套页面可以兼容不同分辨率的设备。* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子* 步骤：    1. 定义容器。相当于之前的table、        * 容器分类：            1. container：两边留白            2. container-fluid：每一种设备都是100%宽度    2. 定义行。相当于之前的tr   样式：row    3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目        * 设备代号：            1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12            2. sm：小屏幕 平板 (≥768px)            3. md：中等屏幕 桌面显示器 (≥992px)            4. lg：大屏幕 大桌面显示器 (≥1200px)    * 注意：        1. 一行中如果格子数目超过12，则超出部分自动换行。        2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。        3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</code></pre><h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><pre><code>1. 全局CSS样式：    * 按钮：class=&quot;btn btn-default&quot;    * 图片：        *  class=&quot;img-responsive&quot;：图片在任意尺寸都占100%        *  图片形状            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框    * 表格        * table        * table-bordered        * table-hover    * 表单        * 给表单项添加：class=&quot;form-control&quot; 2. 组件：    * 导航条    * 分页条3. 插件：    * 轮播图</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</code></pre><p>​<br>        <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --><br>        <script src="js/jquery-3.2.1.min.js"></script><br>        <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --><br>        <script src="js/bootstrap.min.js"></script><br>        <style><br>            .paddtop{<br>                padding-top: 10px;<br>            }<br>            .search-btn{<br>                float: left;<br>                border:1px solid #ffc900;<br>                width: 90px;<br>                height: 35px;<br>                background-color:#ffc900 ;<br>                text-align: center;<br>                line-height: 35px;<br>                margin-top: 15px;<br>            }</p><pre><code>        .search-input{            float: left;            border:2px solid #ffc900;            width: 400px;            height: 35px;            padding-left: 5px;            margin-top: 15px;        }        .jx{            border-bottom: 2px solid #ffc900;            padding: 5px;        }        .company{            height: 40px;            background-color: #ffc900;            text-align: center;            line-height:40px ;            font-size: 8px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;!-- 1.页眉部分--&gt;   &lt;header class=&quot;container-fluid&quot;&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;img src=&quot;img/top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt;       &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;img src=&quot;img/logo.jpg&quot; class=&quot;img-responsive&quot;&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-5&quot;&gt;               &lt;input class=&quot;search-input&quot; placeholder=&quot;请输入线路名称&quot;&gt;               &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-4&quot;&gt;               &lt;img src=&quot;img/hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt;           &lt;/div&gt;       &lt;/div&gt;       &lt;!--导航栏--&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;nav class=&quot;navbar navbar-default&quot;&gt;               &lt;div class=&quot;container-fluid&quot;&gt;                   &lt;!-- Brand and toggle get grouped for better mobile display --&gt;                   &lt;div class=&quot;navbar-header&quot;&gt;                       &lt;!-- 定义汉堡按钮 --&gt;                       &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;                           &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                       &lt;/button&gt;                       &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;                   &lt;/div&gt;                   &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;                   &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;                       &lt;ul class=&quot;nav navbar-nav&quot;&gt;                           &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                       &lt;/ul&gt;                   &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;               &lt;/div&gt;&lt;!-- /.container-fluid --&gt;           &lt;/nav&gt;       &lt;/div&gt;       &lt;!--轮播图--&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;               &lt;!-- Indicators --&gt;               &lt;ol class=&quot;carousel-indicators&quot;&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;               &lt;/ol&gt;               &lt;!-- Wrapper for slides --&gt;               &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;                   &lt;div class=&quot;item active&quot;&gt;                       &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;               &lt;/div&gt;               &lt;!-- Controls --&gt;               &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;               &lt;/a&gt;               &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;               &lt;/a&gt;           &lt;/div&gt;</code></pre><p>​<br>​<br>           </div></p><pre><code>   &lt;/header&gt;   &lt;!-- 2.主体部分--&gt;   &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row jx&quot;&gt;            &lt;img src=&quot;img/icon_5.jpg&quot;&gt;            &lt;span&gt;黑马精选&lt;/span&gt;        &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                    &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;</code></pre><p>​<br>           </div><br>           <div class="row jx"><br>               <img src="img/icon_6.jpg"><br>               <span>国内游</span><br>           </div><br>           <div class="row paddtop"><br>               <div class="col-md-4"><br>                   <img src="img/guonei_1.jpg"><br>               </div><br>               <div class="col-md-8"><br>                   <div class="row"><br>                       <div class="col-md-4"><br>                           <div class="thumbnail"><br>                               <img src="img/jiangxuan_3.jpg" alt=""><br>                               <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p><br>                               <font color="red">&yen; 699</font><br>                           </div><br>                       </div><br>                       <div class="col-md-4"><br>                           <div class="thumbnail"><br>                               <img src="img/jiangxuan_3.jpg" alt=""><br>                               <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p><br>                               <font color="red">&yen; 699</font><br>                           </div></p><pre><code>                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;               &lt;/div&gt;               &lt;div class=&quot;row&quot;&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;</code></pre><p>​<br>                   </div></p><pre><code>           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;!-- 3.页脚部分--&gt;   &lt;footer class=&quot;container-fluid&quot;&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;img src=&quot;img/footer_service.png&quot; class=&quot;img-responsive&quot;&gt;       &lt;/div&gt;       &lt;div class=&quot;row company&quot;&gt;           *******有限公司 版权所有Copyright 2006-2018, All Rights Reserved*       &lt;/div&gt;   &lt;/footer&gt;</code></pre><p>​<br>    </body><br>    </html></p></style></p>]]></content>
      
      
      <categories>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet入门</title>
      <link href="/2019/01/04/servlet1/"/>
      <url>/2019/01/04/servlet1/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. web相关概念回顾2. web服务器软件：Tomcat3. Servlet入门学习</code></pre><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人        * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称        * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。* 快速入门：    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;* 执行原理：    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法* Servlet中的生命周期方法：    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数 load-on-startup 元素标记容器是否应该在web应用程序启动的时候就加载这个servlet    (实例化并调用其init()方法)。它的值必须是一个整数，表示servlet被加载的先后顺序。          如果该元素的值为负数或者没有设置，则容器会当Servlet被请求时再加载。          如果值为正整数或者0时，表示容器在应用启动时就加载并初始化这个servlet，值越小，servlet的优先级           越高，就越先被加载。值相同时，容器就会自己选择顺序来加载。        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target({ElementType.TYPE})            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet {                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                String[] value() default {};//代表urlPatterns()属性配置                String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                WebInitParam[] initParams() default {};                boolean asyncSupported() default false;                String smallIcon() default &quot;&quot;;                String largeIcon() default &quot;&quot;;                String description() default &quot;&quot;;                String displayName() default &quot;&quot;;            }</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heml入门</title>
      <link href="/2019/01/03/html-ke-tang-bi-ji/"/>
      <url>/2019/01/03/html-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. web概念概述2. HTML</code></pre><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。    * 代码：        &lt;html&gt;            &lt;head&gt;                &lt;title&gt;title&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;            &lt;/body&gt;        &lt;/html&gt;3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例</code></pre><p>​<br>​                </p><p>​    </p><pre><code>    3. 图片标签：        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;            &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;            &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;            &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;    4. 列表标签：        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:    5. 链接标签：        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;    6. div和span：        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚    8. 表格标签：        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分      </code></pre><h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性</code></pre><p>​        </p><pre><code>    * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项        * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础入门</title>
      <link href="/2019/01/02/mysql-ji-chu-ke-tang-bi-ji/"/>
      <url>/2019/01/02/mysql-ji-chu-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL</code></pre><p>​    </p><pre><code>4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><p><img src="\images\MySQL数据库、表、数据的关系.bmp" alt=""></p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><p><img src="\images\SQL分类.bmp" alt=""></p><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !            -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;            SELECT * FROM student WHERE age &gt;= 20;            -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;            -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;            -- 查询年龄大于等于20 小于等于30            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;            -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);            -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断            SELECT * FROM student WHERE english IS NULL;            -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;            -- 查询姓名第二个字是化的人            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;            -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;</code></pre><p>​<br>                – 查询姓名中包含德的人<br>                SELECT * FROM student WHERE NAME LIKE ‘%德%’;</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql多表与实务</title>
      <link href="/2019/01/02/mysql-duo-biao-shi-wu-ke-tang-bi-ji/"/>
      <url>/2019/01/02/mysql-duo-biao-shi-wu-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：    select        列名列表    from        表名列表    where....* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)    );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);* 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            SELECT                 t1.name, -- 员工表的姓名                t1.gender,-- 员工表的性别                t2.name -- 部门表的名称            FROM                emp t1,                dept t2            WHERE                 t1.`dept_id` = t2.`id`;</code></pre><p>​    </p><pre><code>        2. 显式内连接：            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;                    * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;            3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段    2. 外链接查询：        1. 左外连接：            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；            * 查询的是左表所有数据以及其交集部分。            * 例子：                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;        2. 右外连接：            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；            * 查询的是右表所有数据以及其交集部分。            * 例子：                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;    3. 子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 查询工资最高的员工信息            -- 1 查询最高的工资是多少 9000            SELECT MAX(salary) FROM emp;            -- 2 查询员工信息，并且工资等于9000的            SELECT * FROM emp WHERE emp.`salary` = 9000;            -- 一条sql就完成这个操作。子查询            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);        * 子查询不同情况            1. 子查询的结果是单行单列的：                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =                *                 -- 查询员工工资小于平均工资的人                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in来判断                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;                -- 子查询                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2                WHERE t1.id = t2.dept_id;                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;    * 多表查询练习            -- 部门表            CREATE TABLE dept (              id INT PRIMARY KEY PRIMARY KEY, -- 部门id              dname VARCHAR(50), -- 部门名称              loc VARCHAR(50) -- 部门所在地            );            -- 添加4个部门            INSERT INTO dept(id,dname,loc) VALUES             (10,&#39;教研部&#39;,&#39;北京&#39;),            (20,&#39;学工部&#39;,&#39;上海&#39;),            (30,&#39;销售部&#39;,&#39;广州&#39;),            (40,&#39;财务部&#39;,&#39;深圳&#39;);</code></pre><p>​<br>​<br>                – 职务表，职务名称，职务描述<br>                CREATE TABLE job (<br>                  id INT PRIMARY KEY,<br>                  jname VARCHAR(20),<br>                  description VARCHAR(50)<br>                );</p><pre><code>            -- 添加4个职务            INSERT INTO job (id, jname, description) VALUES            (1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;),            (2, &#39;经理&#39;, &#39;管理部门员工&#39;),            (3, &#39;销售员&#39;, &#39;向客人推销产品&#39;),            (4, &#39;文员&#39;, &#39;使用办公软件&#39;);</code></pre><p>​<br>​<br>                – 员工表<br>                CREATE TABLE emp (<br>                  id INT PRIMARY KEY, – 员工id<br>                  ename VARCHAR(50), – 员工姓名<br>                  job_id INT, – 职务id<br>                  mgr INT , – 上级领导<br>                  joindate DATE, – 入职日期<br>                  salary DECIMAL(7,2), – 工资<br>                  bonus DECIMAL(7,2), – 奖金<br>                  dept_id INT, – 所在部门编号<br>                  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),<br>                  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)<br>                );</p><pre><code>            -- 添加员工            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES             (1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),            (1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),            (1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),            (1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),            (1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),            (1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),            (1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),            (1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),            (1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),            (1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),            (1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),            (1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),            (1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),            (1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);</code></pre><p>​<br>​<br>                – 工资等级表<br>                CREATE TABLE salarygrade (<br>                  grade INT PRIMARY KEY,   – 级别<br>                  losalary INT,  – 最低工资<br>                  hisalary INT – 最高工资<br>                );</p><pre><code>            -- 添加5个工资等级            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES             (1,7000,12000),            (2,12010,14000),            (3,14010,20000),            (4,20010,30000),            (5,30010,99990);            -- 需求：            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述            /*                分析：                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表                    2.查询条件 emp.job_id = job.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description` -- 职务描述            FROM                 emp t1, job t2            WHERE                 t1.`job_id` = t2.`id`;</code></pre><p>​<br>​<br>                – 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置<br>                /*<br>                    分析：</p><pre><code>                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description`, -- 职务描述                t3.`dname`, -- 部门名称                t3.`loc` -- 部门位置            FROM                 emp t1, job t2,dept t3            WHERE                 t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;            -- 3.查询员工姓名，工资，工资等级            /*                分析：                    1.员工姓名，工资 emp  工资等级 salarygrade                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.ename ,                t1.`salary`,                t2.*            FROM emp t1, salarygrade t2            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;</code></pre><p>​<br>​<br>                – 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级<br>                /*<br>                    分析：</p><pre><code>                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.`ename`,                t1.`salary`,                t2.`jname`,                t2.`description`,                t3.`dname`,                t3.`loc`,                t4.`grade`            FROM                 emp t1,job t2,dept t3,salarygrade t4            WHERE                 t1.`job_id` = t2.`id`                 AND t1.`dept_id` = t3.`id`                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;</code></pre><p>​<br>​<br>                – 5.查询出部门编号、部门名称、部门位置、部门人数</p><pre><code>            /*                分析：                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)                    3.使用子查询将第2步的查询结果和dept表进行关联查询            */            SELECT                 t1.`id`,t1.`dname`,t1.`loc` , t2.total            FROM                 dept t1,                (SELECT                    dept_id,COUNT(id) total                FROM                     emp                GROUP BY dept_id) t2            WHERE t1.`id` = t2.dept_id;</code></pre><p>​<br>                – 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询</p><pre><code>            /*                分析：                    1.姓名 emp， 直接上级的姓名 emp                        * emp表的id 和 mgr 是自关联                    2.条件 emp.id = emp.mgr                    3.查询左表的所有数据，和 交集数据                        * 使用左外连接查询            */            /*            select                t1.ename,                t1.mgr,                t2.`id`,                t2.ename            from emp t1, emp t2            where t1.mgr = t2.`id`;            */            SELECT                 t1.ename,                t1.mgr,                t2.`id`,                t2.`ename`            FROM emp t1            LEFT JOIN emp t2            ON t1.`mgr` = t2.`id`;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍    1. 概念：        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。    2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;    3. 例子：        CREATE TABLE account (            id INT PRIMARY KEY AUTO_INCREMENT,            NAME VARCHAR(10),            balance DOUBLE        );        -- 添加数据        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);</code></pre><p>​<br>            SELECT * FROM account;<br>            UPDATE account SET balance = 1000;<br>            – 张三给李四转账 500 元</p><pre><code>        -- 0. 开启事务        START TRANSACTION;        -- 1. 张三账户 -500        UPDATE account SET balance = balance - 500 WHERE NAME = &#39;zhangsan&#39;;        -- 2. 李四账户 +500        -- 出错了...        UPDATE account SET balance = balance + 500 WHERE NAME = &#39;lisi&#39;;        -- 发现执行没有问题，提交事务        COMMIT;        -- 发现出问题了，回滚事务        ROLLBACK;    4. MySQL数据库中事务默认自动提交        * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle 数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        2. 删除用户：            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        3. 修改用户密码：            UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;            SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;            * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;            -- 给张三用户授予所有权限，在任意数据库任意表上            GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础加强</title>
      <link href="/2019/01/02/mysql-yue-shu-ke-tang-bi-ji/"/>
      <url>/2019/01/02/mysql-yue-shu-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. DQL:查询语句    1. 排序查询    2. 聚合函数    3. 分组查询    4. 分页查询2. 约束3. 多表之间的关系4. 范式5. 数据库的备份和还原</code></pre><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count：计算个数        1. 一般选择非空的列：主键        2. count(*)    2. max：计算最大值    3. min：计算最小值    4. sum：计算和    5. avg：计算平均值    * 注意：聚合函数的计算，排除null值。        解决方案：            1. 选择不包含非空的列进行计算            2. IFNULL函数3. 分组查询:    1. 语法：group by 分组字段；    2. 注意：        1. 分组之后查询的字段：分组字段、聚合函数        2. where 和 having 的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。        -- 按照性别分组。分别查询男、女同学的平均分        SELECT sex , AVG(math) FROM student GROUP BY sex;        -- 按照性别分组。分别查询男、女同学的平均分,人数        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</code></pre><p>​            </p><pre><code>4. 分页查询    1. 语法：limit 开始的索引,每页查询的条数;    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数        -- 每页显示3条记录         SELECT * FROM student LIMIT 0,3; -- 第1页        SELECT * FROM student LIMIT 3,3; -- 第2页        SELECT * FROM student LIMIT 6,3; -- 第3页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    * 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null，值不能为null    1. 创建表时添加约束        CREATE TABLE stu(            id INT,            NAME VARCHAR(20) NOT NULL -- name为非空        );    2. 创建表完后，添加非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20);</code></pre><p>​    </p><pre><code>* 唯一约束：unique，值不能重复    1. 创建表时，添加唯一约束        CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束        );        * 注意mysql中，唯一约束限定的列的值可以有多个null</code></pre><p>​        </p><pre><code>    2. 删除唯一约束        ALTER TABLE stu DROP INDEX phone_number;    3. 在创建表后，添加唯一约束        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 在创建表时，添加主键约束        create table stu(            id int primary key,-- 给id添加主键约束            name varchar(20)        );    3. 删除主键        -- 错误 alter table stu modify id int ;        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建完表后，添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长        2. 在创建表时，添加主键约束，并且完成主键自增长        create table stu(            id int primary key auto_increment,-- 给id添加主键约束            name varchar(20)        );</code></pre><p>​            </p><pre><code>        3. 删除自动增长        ALTER TABLE stu MODIFY id INT;        4. 添加自动增长        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。    1. 在创建表时，可以添加外键        * 语法：            create table 表名(                ....                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre><p>​        </p><pre><code>    4. 级联操作        1. 添加级联操作            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                     FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;        2. 分类：            1. 级联更新：ON UPDATE CASCADE             2. 级联删除：ON DELETE CASCADE </code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。    3. 案例        -- 创建旅游线路分类表 tab_category        -- cid 旅游线路分类主键，自动增长        -- cname 旅游线路分类名称非空，唯一，字符串 100        CREATE TABLE tab_category (            cid INT PRIMARY KEY AUTO_INCREMENT,            cname VARCHAR(100) NOT NULL UNIQUE        );        -- 创建旅游线路表 tab_route        /*        rid 旅游线路主键，自动增长        rname 旅游线路名称非空，唯一，字符串 100        price 价格        rdate 上架时间，日期类型        cid 外键，所属分类        */        CREATE TABLE tab_route(            rid INT PRIMARY KEY AUTO_INCREMENT,            rname VARCHAR(100) NOT NULL UNIQUE,            price DOUBLE,            rdate DATE,            cid INT,            FOREIGN KEY (cid) REFERENCES tab_category(cid)        );        /*创建用户表 tab_user        uid 用户主键，自增长        username 用户名长度 100，唯一，非空        password 密码长度 30，非空        name 真实姓名长度 100        birthday 生日        sex 性别，定长字符串 1        telephone 手机号，字符串 11        email 邮箱，字符串长度 100        */        CREATE TABLE tab_user (            uid INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(100) UNIQUE NOT NULL,            PASSWORD VARCHAR(30) NOT NULL,            NAME VARCHAR(100),            birthday DATE,            sex CHAR(1) DEFAULT &#39;男&#39;,            telephone VARCHAR(11),            email VARCHAR(100)        );        /*        创建收藏表 tab_favorite        rid 旅游线路 id，外键        date 收藏时间        uid 用户 id，外键        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次        */        CREATE TABLE tab_favorite (            rid INT, -- 线路id            DATE DATETIME,            uid INT, -- 用户id            -- 创建复合主键            PRIMARY KEY(rid,uid), -- 联合主键            FOREIGN KEY (rid) REFERENCES tab_route(rid),            FOREIGN KEY(uid) REFERENCES tab_user(uid)        );</code></pre><p>​        </p><pre><code>2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：    * 语法：        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2. 图形化工具：</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC加强</title>
      <link href="/2019/01/02/jdbc-lian-jie-chi-jdbctemplate-ke-tang-bi-ji/"/>
      <url>/2019/01/02/jdbc-lian-jie-chi-jdbctemplate-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><p><img src="\images\数据库连接池.bmp" alt=""></p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils {            //1.定义成员变量 DataSource            private static DataSource ds ;            static{                try {                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                } catch (IOException e) {                    e.printStackTrace();                } catch (Exception e) {                    e.printStackTrace();                }            }            /**             * 获取连接             */            public static Connection getConnection() throws SQLException {                return ds.getConnection();            }            /**             * 释放资源             */            public static void close(Statement stmt,Connection conn){               /* if(stmt != null){                    try {                        stmt.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }*/               close(null,stmt,conn);            }</code></pre><p>​<br>                public static void close(ResultSet rs , Statement stmt, Connection conn){</p><p>​<br>                    if(rs != null){<br>                        try {<br>                            rs.close();<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }</p><p>​<br>                    if(stmt != null){<br>                        try {<br>                            stmt.close();<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }</p><pre><code>                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }            }            /**             * 获取连接池方法             */            public static DataSource getDataSource(){                return  ds;            }        }</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：            import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;            import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;            public class JdbcTemplateDemo2 {                //Junit单元测试，可以让方法独立执行</code></pre><p>​<br>                    //1. 获取JDBCTemplate对象<br>                    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());<br>                    /**</p><pre><code>                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1(){                    //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                }                /**                 * 2. 添加一条记录                 */                @Test                public void test2(){                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                }                /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3(){                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                }                /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4(){                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}                }                /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                    for (Map&lt;String, Object&gt; stringObjectMap : list) {                        System.out.println(stringObjectMap);                    }                }                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() {                        @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException {                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                            emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                            return emp;                        }                    });</code></pre><p>​<br>                        for (Emp emp : list) {<br>                            System.out.println(emp);<br>                        }<br>                    }</p><pre><code>                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6_2(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) {                        System.out.println(emp);                    }                }                /**                 * 7. 查询总记录数                 */                @Test                public void test7(){                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                }            }</code></pre>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库连接池 </tag>
            
            <tag> JDBC Template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC入门</title>
      <link href="/2019/01/02/jdbc-ke-tang-bi-ji/"/>
      <url>/2019/01/02/jdbc-ke-tang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. JDBC基本概念2. 快速入门3. 对JDBC中各个接口和类详解</code></pre><p><img src="\images\JDBC本质.bmp" alt=""></p><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static {                        try {                            java.sql.DriverManager.registerDriver(new Driver());                        } catch (SQLException E) {                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                        }                    }                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try {                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0){                        System.out.println(&quot;添加成功！&quot;);                    }else{                        System.out.println(&quot;添加失败！&quot;);                    }                } catch (ClassNotFoundException e) {                    e.printStackTrace();                } catch (SQLException e) {                    e.printStackTrace();                }finally {                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null){                        try {                            stmt.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                    if(conn != null){                        try {                            conn.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                }    4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next()){                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                }        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll(){}                3. 实现方法 select * from emp;    5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a            2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils {    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static{        //读取资源文件，获取值。        try {            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }</code></pre><p>​<br>        /**</p><pre><code>     * 获取连接     * @return 连接对象     */    public static Connection getConnection() throws SQLException {        return DriverManager.getConnection(url, user, password);    }    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(Statement stmt,Connection conn){        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }</code></pre><p>​<br>        /**</p><pre><code>     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn){        if( rs != null){            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)            );            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);        2. 代码实现：            public class JDBCDemo9 {                public static void main(String[] args) {                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag){                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    }else{                        System.out.println(&quot;用户名或密码错误！&quot;);                    }</code></pre><p>​<br>                    }</p><p>​<br>​<br>                    /**</p><pre><code>                 * 登录方法                 */                public boolean login(String username ,String password){                    if(username == null || password == null){                        return false;                    }                    //连接数据库判断是否登录成功                    Connection conn = null;                    Statement stmt =  null;                    ResultSet rs = null;                    //1.获取连接                    try {                        conn =  JDBCUtils.getConnection();                        //2.定义sql                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;                        //3.获取执行sql的对象                        stmt = conn.createStatement();                        //4.执行查询                        rs = stmt.executeQuery(sql);                        //5.判断                       /* if(rs.next()){//如果有下一行，则返回true                            return true;                        }else{                            return false;                        }*/                       return rs.next();//如果有下一行，则返回true                    } catch (SQLException e) {                        e.printStackTrace();                    }finally {                        JDBCUtils.close(rs,stmt,conn);                    }</code></pre><p>​<br>                        return false;<br>                    }<br>                }</p><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()         * 当所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务4. 代码：    public class JDBCDemo10 {        public static void main(String[] args) {            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;            try {                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                pstmt2.executeUpdate();                //提交事务                conn.commit();            } catch (Exception e) {                //事务回滚                try {                    if(conn != null) {                        conn.rollback();                    }                } catch (SQLException e1) {                    e1.printStackTrace();                }                e.printStackTrace();            }finally {                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            }</code></pre><p>​<br>            }</p><pre><code>    }</code></pre><p>​            </p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础增强</title>
      <link href="/2019/01/01/ji-chu-jia-qiang-bi-ji/"/>
      <url>/2019/01/01/ji-chu-jia-qiang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. Junit单元测试2. 反射3. 注解</code></pre><h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><pre><code>* 测试分类：    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。    2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试    * 步骤：        1. 定义一个测试类(测试用例)            * 建议：                * 测试类名：被测试的类名Test        CalculatorTest                * 包名：xxx.xxx.xx.test        cn.itcast.test        2. 定义测试方法：可以独立运行            * 建议：                * 方法名：test测试的方法名        testAdd()                  * 返回值：void                * 参数列表：空参        3. 给方法加@Test        4. 导入junit依赖环境    * 判定结果：        * 红色：失败        * 绿色：成功        * 一般我们会使用断言操作来处理结果            * Assert.assertEquals(期望的结果,运算的结果);    * 补充：        * @Before:            * 修饰的方法会在测试方法之前被自动执行        * @After:            * 修饰的方法会在测试方法执行之后自动被执行</code></pre><h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class：通过类名的属性class获取        * 多用于参数的传递    3. 对象.getClass()：getClass()方法在Object类中定义着。        * 多用于对象的获取字节码的方式    * 结论：        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</code></pre><p><img src="\images\java基础增强.bmp" alt=""></p><pre><code>* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFields() ：获取所有public修饰的成员变量            * Field getField(String name)   获取指定名称的 public修饰的成员变量            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符            * Field getDeclaredField(String name)          2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()              * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;?&gt;[] getDeclaredConstructors()          3. 获取成员方法们：            * Method[] getMethods()              * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)              * Method[] getDeclaredMethods()              * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)          4. 获取全类名                * String getName()  * Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)          2. 获取值            * get(Object obj)         3. 忽略访问权限修饰符的安全检查            * setAccessible(true):暴力反射* Constructor:构造方法    * 创建对象：        * T newInstance(Object... initargs)          * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)      * 获取方法名称：        * String getName:获取方法名* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        * 实现：            1. 配置文件            2. 反射        * 步骤：            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中            2. 在程序中加载读取配置文件            3. 使用反射技术来加载类文件进内存            4. 创建对象            5. 执行方法</code></pre><h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><pre><code>* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述：    * JDK1.5之后的新特性    * 说明程序的    * 使用注解：@注解名称</code></pre><p>​    </p><pre><code>* 作用分类：    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】* JDK中预定义的一些注解    * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的    * @Deprecated：该注解标注的内容，表示已过时    * @SuppressWarnings：压制警告        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)* 自定义注解    * 格式：        元注解        public @interface 注解名称{            属性列表;        }    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口        * public interface MyAnno extends java.lang.annotation.Annotation {}    * 属性：接口中的抽象方法        * 要求：            1. 属性的返回值类型有下列取值                * 基本数据类型                * String                * 枚举                * 注解                * 以上类型的数组            2. 定义了属性，在使用时需要给属性赋值                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。                3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略    * 元注解：用于描述注解的注解        * @Target：描述注解能够作用的位置            * ElementType取值：                * TYPE：可以作用于类上                * METHOD：可以作用于方法上                * FIELD：可以作用于成员变量上        * @Retention：描述注解被保留的阶段            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到        * @Documented：描述注解是否被抽取到api文档中        * @Inherited：描述注解是否被子类继承* 在程序使用(解析)注解：获取注解中定义的属性值    1. 获取注解定义的位置的对象  （Class，Method,Field）    2. 获取指定的注解        * getAnnotation(Class)        //其实就是在内存中生成了一个该注解接口的子类实现对象                public class ProImpl implements Pro{                    public String className(){                        return &quot;cn.itcast.annotation.Demo1&quot;;                    }                    public String methodName(){                        return &quot;show&quot;;                    }                }    3. 调用注解中的抽象方法获取配置的属性值* 案例：简单的测试框架* 小结：    1. 以后大多数时候，我们会使用注解，而不是自定义注解    2. 注解给谁用？        1. 编译器        2. 给解析程序用    3. 注解不是程序的一部分，可以理解为注解就是一个标签</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2019/01/01/duo-tai/"/>
      <url>/2019/01/01/duo-tai/</url>
      
        <content type="html"><![CDATA[<ul><li><p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性<br>   编译时多态：重载</p><p>   ​    运行时多态（编译类型和运行类型不一致）：</p><p>   ​            1. 重写</p><p>   ​                    2. 父类或者接口指向子类对象（向上转型）</p></li><li><p>前提：  继承父类或实现接口</p><p>  ​        并重写方法。</p></li><li><p>好处：提高代码扩展性，前期定义的代码可以使用后期的内容</p><pre><code> 如果方法被子类重写会调用子类的方法（多态的最大好处） （如果子类中没有覆盖该方法，那么会去父类中寻找） </code></pre></li><li><p>弊端：对于子类特有中的方法访问不到。<br>   子类的属性，访问不到。即使与父类重名的属性，也是访问父类的属性（覆盖只发生在方法上）。</p></li><li><p>多态时成员的访问特点：</p><p>   成员变量：编译和运行都是看左边（编译能不能通过和实际运行的都是父类或者接口里边的）<br>   成员方法：编译是左边的，运行是右边的<br>   静态方法：编译和运行都是看左边。</p><pre><code>           静态是属于类的，直接用类名调用</code></pre></li></ul><pre><code>package cn.test;public class Animal {    public void eat(){        System.out.println(&quot;动物吃饭&quot;);    }    public void sleep(){        System.out.println(&quot;动物睡觉&quot;);    }}class Dog extends Animal{    public void eat(){        System.out.println(&quot;狗吃骨头&quot;);    }    public void like(){        System.out.println(&quot;狗抓老鼠&quot;);    }}class Cat extends Animal{    public void eat(){        System.out.println(&quot;猫吃鱼&quot;);    }    public void like(){        System.out.println(&quot;喜欢抓老鼠&quot;);    }}class Duotai{    public static void main(String[] args) {        //父类型指向子类对象        Animal am = new Cat();        method(am);//同一操作作用于不同的对象，有不同的结果。        // Animal am1 = new Dog();        //method(am1);    }    /**     * 这实际上就是设计模式中的简单工厂模式!     *     * 类型的参数.,传入参数的时候,可以传入任何一个类的对象，只要是对应的类的对象名称就可以了     * 这就是多态的应用!     * */    public static void method(Animal animal){        animal.eat();    }}</code></pre><ul><li><p>向下转型</p><p><em>向下转型注意事项</em></p><ul><li>在向下转型之前，它得先向上转型。（不然编译能通过，运行无法通过）</li><li>向下转型只能转型为本类对象，子类引用不能指向父类对象。</li></ul><p>转型：自始至终，都是子类对象在做着类型的变化</p></li></ul><pre><code>public static void main(String[] args) {        //父类型指向子类对象，向上转型，猫提升为动物类型        Animal am = new Cat();        //am.like();特有方法无法访问。         //向下转型 ,为了使用子类特有的方法        Cat cat =(Cat)am;        cat.like();        }</code></pre><ul><li>instanceof  </li></ul><pre><code>boolean result = cat instanceof Animal</code></pre><p>其中 cat为一个对象，Animal 表示一个类或者一个接口</p><p>当 cat为 Animal 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
